# Orin配置PPS与NTP
## 1 参考文档
- [GPSD文档](https://gpsd.gitlab.io/gpsd/gpsd.html)
- [NTP server配置](https://www.eecis.udel.edu/~mills/ntp/html/drivers/)
- [Linux使用gpsd获取GPS数据](https://blog.csdn.net/yiyu20180729/article/details/136340493?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-3-136340493-blog-119249223.235%5Ev43%5Epc_blog_bottom_relevance_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-3-136340493-blog-119249223.235%5Ev43%5Epc_blog_bottom_relevance_base2&utm_relevant_index=6)
- [基于LinuxPPS的高精度校时系统实现](https://www.doc88.com/p-7478992186790.html?r=1)
- [嵌入式Linux时间同步gpsd+chrony](https://blog.csdn.net/sep4075/article/details/119249223?spm=1001.2014.3001.5506)
- [时间同步之给工控机授时（PPS+GPRMC）](https://blog.csdn.net/m0_46611008/article/details/126289705?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-8-126289705-blog-120728557.235^v43^pc_blog_bottom_relevance_base2&spm=1001.2101.3001.4242.5&utm_relevant_index=11)
- [Xavier+GPS/PPS+NTP时间设置](https://blog.csdn.net/enlaihe/article/details/120728557?spm=1001.2014.3001.5506)

## 2 驱动修改
### 2.1 Hermes
Hermes用的GPIO29，进行如下修改
```shell
# 新建 Linux_for_Tegra/source/public/hardware/nvidia/platform/t23x/concord/kernel-dts/cvb/tegra234-p3737-0000-pps-gpio29-a00.dtsi
/* pps control gpio definitions */

/ {
    pps: pps-gpio {
        compatible = "pps-gpio";
        gpios = <&tegra_main_gpio TEGRA234_MAIN_GPIO(AC, 4) GPIO_ACTIVE_HIGH>;
        assert-rising-edge;
        // assert-falling-edge;
        status = "okay";
    };
};
```
NOTE: EIS860用的引脚是GPIO08，查表知对应的customer usage为`PBB01`，根据`Linux_for_Tegra/bootloader/tegra234-gpio.h`中`TEGRA234_AON_GPIO_PORT_BB 1`,修改此文件内容为
```shell
/* pps control gpio definitions */

/ {
    pps: pps-gpio {
        compatible = "pps-gpio";
        gpios = <&tegra_aon_gpio TEGRA234_AON_GPIO(BB, 1) GPIO_ACTIVE_HIGH>;
        assert-rising-edge;
        // assert-falling-edge;
        status = "okay";
    };
};
```
修改总设备树，修改`Linux_for_Tegra/source/public/hardware/nvidia/platform/t23x/concord/kernel-dts/tegra234-p3701-0000-p3737-0000.dts`
```shell
#include "cvb/tegra234-p3737-0000-pps-gpio29-a00.dtsi"
```
修改编译选项`source/public/kernel/kernel-5.10/arch/arm64/configs/defconfig`
```shell
CONFIG_PPS=y
CONFIG_PPS_CLIENT_GPIO=y
```
如果dmesg有报错，需要将`CONFIG_PPS_CLIENT_GPIO`设置为m，手动加载`pps-gpio.ko`文件。
编译并升级dtb文件，待机器重启后，查看如下设备节点：
PPS 设备节点： /dev/pps0
Sysfs文件节点: /sys/class/pps/pps0/
每当GPS的PPS过来后，会在对应的GPIO上升沿时会产生一个中断信号，此时也会产生一个timestamp时间戳，通过如下命令查看：
```shell
cat /sys/class/pps/pps0/assert
```
## 3 配置gpsd
安装依赖
```shell
apt install gpsd gpsd-clients pps-tools
```
修改 `/etc/default/gpsd`，根据实际串口名
```shell
# Default settings for gpsd.
# Please do not edit this file directly - use `dpkg-reconfigure gpsd' to
# change the options.
# Default settings for gpsd
START_DAEMON="true"
GPSD_OPTIONS="-n"
DEVICES="/dev/ttyUSB0 /dev/pps0"
USBAUTO="false"
GPSD_SOCKET="/var/run/gpsd.sock"

#注意DEVICE的一行需要根据实际情况填写，上面为COM2口，默认是pps0
#推荐事先验证并查找对应的端口和pps
#使用 ppsfind --help
#输出示例：pps0: name=serial1 path=/dev/ttyUSB0   也就代表着我们现在用的是ttyUSB0以及pps0
```
测试NMEA
```shell
#可以使用cgps或者gpsmon
cgps -s
gpsmon
```



## 4 配置NTP server
```shell
apt install ntp -y
# 根据参考文档配置ntp server
# /etc/ntp.conf
# /etc/ntp.conf, configuration for ntpd; see ntp.conf(5) for help
# Drift file to remember clock rate across restarts
driftfile /var/lib/ntp/ntp.drift
# fudge:  flag 1 for use PPS (/dev/pps0), time2 for calibration time offset
server 127.127.28.0
fudge 127.127.28.0 flag1 1 time2 0.000 refid PPS
```
重启服务验证
```shell
     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
*SHM(0)          .PPS.            0 l   16   64   77    0.000   65.707  31.054
```

## 5 Debug

如果运行命令 `cat /sys/class/pps/pps0/assert` 后返回`0.000000000#0`，这通常表明未检测到有效的 PPS（Pulse Per Second）信号。GPS未接收到信号可能是造成这种情况的原因。以下是解决问题的步骤：

---

### 5.1 **检查硬件连接**
   - 确保 GPS 模块的信号线（PPS 和 TX）已正确连接到系统的 GPIO 或串口。
   - 检查电源是否正常供给 GPS 模块。
   - 使用万用表测量 PPS 引脚是否有脉冲信号输出。

---

### 5.2 **检查 GPS 天线**
   - 确保 GPS 天线已正确连接并放置在开阔的环境中，避免天线被建筑物遮挡。
   - 如果使用的是主动天线，检查是否已为天线供电。

---

### 5.3 **验证 GPS 模块工作状态**
   - **通过串口查看 GPS 数据**：
     使用串口工具（如 `minicom` 或 `screen`）查看 GPS 模块是否输出 NMEA 数据：
     ```bash
     # 自带工具stty查看波特率
     stty -F /dev/ttyUSB0
     # 自带工具stty设置波特率
     stty -F /dev/ttyUSB0 9600
     # minicom设置波特率
     sudo minicom -D /dev/ttyS0 -b 9600
     ```
     根据 GPS 模块的默认波特率调整参数。如果 GPS 模块正常工作，应能看到类似以下内容：
     ```
     $GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47
     ```
   - 如果无数据输出：
     - 检查波特率是否正确。
     - 确认设备是否被系统识别（`ls /dev/tty*`）。
     - 确认串口连接是否正常。
   - EIS860可以使用`/opt/tools/EIS860_GPS/`下的脚本来获取GPS数据。

---

### 4. **检查 PPS 配置**
   - 验证内核是否支持 PPS：
     ```bash
     dmesg | grep pps
     ```
     如果内核支持 PPS，应能看到类似以下信息：
     ```
     pps_core: LinuxPPS API ver. 1 registered
     pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti
     ```
   - 检查 `/sys/class/pps/pps0` 是否存在：
     ```bash
     ls /sys/class/pps/
     ```
     如果 `/sys/class/pps/pps0` 不存在，可能是 PPS 信号未正确连接或驱动未加载。**如果存在，说明驱动正常。**

---

### 5. **确认 GPS 定位状态**
   - NMEA 数据中 `$GPGGA` 的第 7 个字段（E后面的字段）表示定位状态：
     - `0` 表示未定位。
     - `1` 表示已获得固定位置（定位成功）。
     - `2` 表示差分定位。
   - 如果状态为 `0`：
     - 检查 GPS 模块是否已初始化。
     - 确保天线放置环境适合接收卫星信号。

---

### 6. **诊断工具**
   - 安装 `gpsd` 和 `gpsmon` 进行调试：
     ```bash
     sudo apt install gpsd gpsd-clients
     sudo gpsmon /dev/ttyS0
     ```
     在 `gpsmon` 界面中可以观察卫星数量和信号质量。如果未显示卫星，可能是天线问题或模块未工作。

---

### 7. **日志检查**
   查看系统日志中的 GPS 和 PPS 相关信息：
   ```bash
   dmesg | grep -i gps
   dmesg | grep -i pps
   ```

---

### 8. **环境和配置问题**
   - 检查系统时间是否正确：
     ```bash
     timedatectl
     ```
   - 如果 GPS 需要冷启动，等待更长时间以便完成首次定位（通常需要几分钟）。
## 6 TEMP

在 Jetson AGX Orin 上使用 **NTPD (ntpd) + GPS + PPS** 进行高精度授时，可以按照以下步骤配置：

---

## **1. 安装 NTP 相关软件**
```bash
sudo apt update
sudo apt install ntp gpsd gpsd-clients pps-tools
```

---

## **2. 确保系统识别 PPS 和 GPS 设备**
检查 `/dev/pps0` 是否存在：
```bash
ls -l /dev/pps*
```
检查 GPS 设备（可能是 `/dev/ttyUSB0` 或 `/dev/ttyACM0`）：
```bash
ls -l /dev/ttyUSB* /dev/ttyACM*
```
如果 GPS 设备存在，可以用 `gpsmon` 或 `cgps` 查看数据：
```bash
sudo gpsmon /dev/ttyUSB0
```
或者：
```bash
sudo cgps -s
```
如果数据正常输出，说明 GPS 设备可用。

---

## **3. 配置 GPSD**
编辑 `/etc/default/gpsd`：
```bash
sudo nano /etc/default/gpsd
```
修改内容如下：
```ini
START_DAEMON="true"
GPSD_OPTIONS="-n"
DEVICES="/dev/ttyUSB0 /dev/pps0"
USBAUTO="false"
GPSD_SOCKET="/var/run/gpsd.sock"
```
然后重启 `gpsd`：
```bash
sudo systemctl restart gpsd
```
测试 GPS 是否工作：
```bash
cgps -s
```

---

## **4. 配置 NTPD**
### **4.1 编辑 ntp.conf**
修改 `/etc/ntp.conf`：
```bash
sudo nano /etc/ntp.conf
```
添加以下内容：

```ini
# 允许本机时间同步
restrict 127.0.0.1
restrict ::1

# 其他 NTP 服务器（可选，作为辅助时间源）
server ntp.aliyun.com iburst
server time.google.com iburst

# GPS 共享内存驱动 (单位: 秒)
server 127.127.28.0 minpoll 4 maxpoll 4 prefer
fudge 127.127.28.0 time1 0.0 refid GPS

# PPS 设备 (精确时间同步)
server 127.127.22.0 minpoll 3 maxpoll 3 prefer
fudge 127.127.22.0 refid PPS flag3 1

# 允许本机访问 NTP
restrict 127.0.0.1
restrict ::1
```

**参数解释：**
- `server 127.127.28.0` → 使用 `SHM` 驱动从 `gpsd` 读取 GPS 时间
- `server 127.127.22.0` → 使用 `PPS` 进行高精度同步
- `fudge 127.127.28.0 time1 0.0 refid GPS` → 设置 GPS 数据的偏移
- `fudge 127.127.22.0 refid PPS flag3 1` → 使 PPS 为主时钟

---

### **4.2 重新启动 NTP 服务**
```bash
sudo systemctl restart ntp
```
并检查服务是否运行：
```bash
systemctl status ntp
```

---

## **5. 验证 NTP 是否同步**
### **5.1 检查 NTP 服务器状态**
```bash
ntpq -p
```
示例输出：
```
     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
*PPS(0)          .PPS.        0 l   7   16  377    0.000    0.002   0.001
+SHM(0)          .GPS.        0 l   9   64  377    0.000   -0.024   0.012
+time.google.com .GOOG.       1 u   8   64  377   10.344    0.300   0.150
```
如果 `PPS(0)` 前面有 `*`，说明 PPS 授时已成功。

---

### **5.2 检查 NTP 追踪状态**
```bash
ntptime
```
示例输出：
```
ntp_gettime() returns code 0 (OK)
  time e8a5d3f2.c3b7d000  Mon, Feb 11 2025 15:10:42.765 UTC
  precision -20 (0.953us)
  root delay 0.000000 s
  root dispersion 0.000061 s
  reference time:  e8a5d3f2.c3b7d000  (Mon, Feb 11 2025 15:10:42.765 UTC)
```

如果 `reference time` 来源是 `PPS`，说明 Jetson AGX Orin 正确使用 PPS 进行授时。

---

## **6. 设置 Jetson AGX Orin 开机自动同步**
确保 `ntpd` 和 `gpsd` 在开机时自动运行：
```bash
sudo systemctl enable gpsd
sudo systemctl enable ntp
```

---

## **7. 手动强制同步时间（如果时间偏差较大）**
如果 `ntpd` 运行后时间偏差较大，可以手动同步：
```bash
sudo ntpd -gq
```
或者：
```bash
sudo ntpq -c "rv 0"
```

---

## **总结**
1. **安装 NTPD 和 GPSD**
2. **确认 GPS 和 PPS 设备正常工作**
3. **配置 GPSD 读取 GPS 数据**
4. **修改 `ntp.conf`，启用 `PPS` 和 `GPS` 授时**
5. **重启 `ntpd` 并检查同步状态**
6. **设置开机自动同步**
7. **验证 `ntpq -p`，确保 `PPS` 成为主时钟**

这样，Jetson AGX Orin 就能使用 **PPS+GPS** 进行高精度授时了！ 🎯🚀


在 **Jetson AGX Orin** 上使用 **PPS + GPS** 进行授时后，可以通过以下方式来评估授时精度。

---

## **1. 通过 `ntpq` 或 `chronyc` 检查偏差**
### **如果使用 `ntpd`，运行：**
```bash
ntpq -p
```
示例输出：
```
     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
*PPS(0)          .PPS.        0 l   7   16  377    0.000    0.002   0.001
+SHM(0)          .GPS.        0 l   9   64  377    0.000   -0.024   0.012
+time.google.com .GOOG.       1 u   8   64  377   10.344    0.300   0.150
```
关键参数：
- `offset`（偏移量，单位：毫秒或微秒）：反映本机时间与授时源的偏差。
  - 如果 `PPS` 为 `*`，并且 `offset` 在 `±0.002 ms` 内，则授时精度在 **2 µs** 级别。
- `jitter`（抖动，单位：毫秒或微秒）：表示授时数据的波动范围。

---

### **如果使用 `chrony`，运行：**
```bash
chronyc tracking
```
示例输出：
```
Reference ID    : PPS
Stratum         : 1
Ref time (UTC)  : Mon Feb 11 15:20:42 2025
System time     : 0.000000001 seconds fast of NTP time
Last offset     : +0.000000002 seconds
RMS offset      : 0.000000001 seconds
```
- `Last offset` 和 `RMS offset` 反映当前授时精度，如果数值在 **±1 ns ~ ±100 ns** 之间，则说明授时精度极高（纳秒级）。

---

## **2. 通过 `ntptime` 检查系统授时精度**
```bash
ntptime
```
示例输出：
```
ntp_gettime() returns code 0 (OK)
  time e8a5d3f2.c3b7d000  Mon, Feb 11 2025 15:25:42.765 UTC
  precision -20 (0.953us)
  root delay 0.000000 s
  root dispersion 0.000061 s
  reference time:  e8a5d3f2.c3b7d000  (Mon, Feb 11 2025 15:25:42.765 UTC)
```
- `precision` 为 `-20`，表示时间精度为 **0.953 µs**。
- `root dispersion` 为 `0.000061 s`，表示最大误差为 **61 µs**。

---

## **3. 通过 `ppstest` 测试 PPS 精度**
如果使用 **PPS** 进行授时，可以用 `ppstest` 查看时间戳：
```bash
sudo ppstest /dev/pps0
```
示例输出：
```
trying PPS source "/dev/pps0"
found PPS source "/dev/pps0"
timestamp: 1707665702.999999994    precision: 1e-9
timestamp: 1707665703.000000003    precision: 1e-9
```
- 观察 `timestamp` 的小数部分，如果变化接近整秒（如 `0.999999994` 和 `0.000000003`），说明 PPS 精度在 **纳秒级（ns）**。

---

## **4. 通过 oscilloscope (示波器) 物理测量**
对于更精确的测量，可以用示波器：
1. 连接 **PPS 信号** 到示波器的通道 1，连接 **系统时间输出（如 GPIO 时钟）** 到通道 2。
2. 使用 **触发模式** 对比两者的时间差。
3. 如果 PPS 和系统时间对齐误差在 **100 ns ~ 1 µs**，说明授时精度已达到亚微秒级别。

---

## **5. 典型授时精度范围**
| 授时方式    | 典型精度   | 备注 |
|------------|-----------|------|
| 仅 NTP（公网） | 1~100 ms | 受网络延迟影响 |
| GPS 无 PPS | 10~100 ms | 受 GPS 计算延迟影响 |
| GPS + PPS + NTPD | 1~10 µs | 受系统 jitter 影响 |
| GPS + PPS + Chrony | 10~100 ns | 最佳配置，适合 Jetson |

---

### **结论**
在 Jetson AGX Orin 上：
- **仅使用 GPS 授时**：误差 **10~100 ms**。
- **使用 GPS + PPS + NTPD**：误差 **1~10 µs**。
- **使用 GPS + PPS + Chrony**：误差 **10~100 ns**（纳秒级）。

如果需要更高精度（如 10 ns 级别），建议使用 **Chrony**，并优化系统内核（如 `PREEMPT-RT` 实时内核）。 🚀

## 3 PPS信号监测


### **1️⃣ `PPS` 监测脚本**
**功能更新：**
- 记录 `Error` 数据到 `pps_errors.log`
- 记录时间戳，便于后续分析
- 输出统计信息

保存为 `monitor_pps.py`：
```python
import subprocess
import re
import time
import statistics

LOG_FILE = "pps_errors.log"

# 运行 ppstest 进程
cmd = ["ppstest", "/dev/pps0"]
process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

assert_times = []
errors = []

print("Monitoring PPS assert intervals...\n")

with open(LOG_FILE, "w") as log_file:
    log_file.write("Timestamp,Error (μs)\n")  # 写入表头

try:
    while True:
        line = process.stdout.readline()
        if not line:
            break

        # 匹配 assert 事件时间
        match = re.search(r"assert (\d+\.\d+)", line)
        if match:
            timestamp = float(match.group(1))
            assert_times.append(timestamp)

            # 计算相邻 assert 之间的时间误差
            if len(assert_times) > 1:
                interval = assert_times[-1] - assert_times[-2]
                expected_interval = 1.0  # 期望间隔 1 秒
                error = (interval - expected_interval) * 1e6  # 误差转换为 μs（微秒）

                errors.append(error)
                current_time = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(timestamp))
                print(f"{current_time} | Interval: {interval:.9f} s, Error: {error:.3f} μs")

                # 记录到日志文件
                with open(LOG_FILE, "a") as log_file:
                    log_file.write(f"{current_time},{error:.3f}\n")

            # 每 10 个数据点，计算误差统计
            if len(errors) >= 10:
                min_error = min(errors)
                max_error = max(errors)
                avg_error = sum(errors) / len(errors)
                std_dev = statistics.stdev(errors) if len(errors) > 1 else 0

                print(f"\n[Stats] Min: {min_error:.3f} μs, Max: {max_error:.3f} μs, "
                      f"Avg: {avg_error:.3f} μs, StdDev: {std_dev:.3f} μs\n")

                errors.clear()  # 清空误差列表，继续统计

except KeyboardInterrupt:
    print("\nStopping monitoring...")
    process.terminate()
```
---

### **2️⃣ 误差变化趋势绘图脚本**
**功能更新：**
- 读取 `pps_errors.log` 文件
- 绘制 `Error` 误差的变化趋势
- 显示误差随时间的分布

保存为 `plot_pps_errors.py`：
```python
import matplotlib.pyplot as plt
import pandas as pd
from pandas.plotting import register_matplotlib_converters

register_matplotlib_converters()

LOG_FILE = "pps_errors.log"

# 读取日志文件
df = pd.read_csv(LOG_FILE)

# 解析时间戳
df["Timestamp"] = pd.to_datetime(df["Timestamp"])
df = df.sort_values(by="Timestamp")  # 确保数据按时间排序

# 画图
plt.figure(figsize=(10, 5))
plt.plot(df["Timestamp"], df["Error (μs)"], marker="o", linestyle="-", color="b", label="PPS Error (μs)")
plt.axhline(y=0, color="r", linestyle="--", label="Ideal Error = 0")
plt.xlabel("Time")
plt.ylabel("Error (μs)")
plt.title("PPS Error Over Time")
plt.legend()
plt.grid()

# 显示图表
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()
```
---

### **3️⃣ 使用方法**
**运行 `PPS` 监测脚本（记录数据）：**
```bash
python3 monitor_pps.py
```
**运行绘图脚本（分析数据）：**
```bash
python3 plot_pps_errors.py
```
---

### **4️⃣ 输出示例**
#### **📜 日志 (`pps_errors.log`) 示例**
```
Timestamp,Error (μs)
2025-03-04 12:00:01,-3.250
2025-03-04 12:00:02,1.873
2025-03-04 12:00:03,-2.540
...
```
#### **📈 绘图示例**
✅ **误差变化趋势图**
- X 轴：时间戳
- Y 轴：`PPS Error (μs)`
- 蓝色折线：误差变化趋势
- 红色虚线：理想误差 `0 μs` 参考线

---

这样，不仅可以监测 `PPS` 误差，还可以通过 `plot_pps_errors.py` 可视化分析误差的变化趋势