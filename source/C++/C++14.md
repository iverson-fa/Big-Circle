# C++14

## 概述

C++14 包含以下新语言特性：
- [二进制字面量](#二进制字面量)
- [泛型lambda表达式](#泛型lambda表达式)
- [Lambda捕获初始化器](#lambda捕获初始化器)
- [返回类型推导](#返回类型推导)
- [decltype(auto)](#decltypeauto)
- [放宽constexpr函数的限制](#放宽constexpr函数的限制)
- [变量模板](#变量模板)
- [\[\[deprecated\]\]属性](#deprecated属性)

C++14 包含以下新库特性：
- [标准库类型的用户定义字面量](#标准库类型的用户定义字面量)
- [编译时整数序列](#编译时整数序列)
- [std::make_unique](#stdmake_unique)

## C++14 语言特性

### 二进制字面量
二进制字面量提供了一种方便的方式来表示二进制数字。
可以使用 `'` 分隔数字。
```cpp
0b110 // == 6
0b1111'1111 // == 255
```

### 泛型Lambda表达式
C++14 现在允许在参数列表中使用 `auto` 类型说明符，从而实现多态lambda。
```cpp
auto identity = [](auto x) { return x; };
int three = identity(3); // == 3
std::string foo = identity("foo"); // == "foo"
```

### Lambda捕获初始化器
这允许使用任意表达式初始化lambda捕获。捕获值的名称不需要与外部作用域中的任何变量相关，并在lambda体内引入一个新名称。初始化表达式在lambda_创建时_求值（而不是在_调用时_）。
```cpp
int factory(int i) { return i * 10; }
auto f = [x = factory(2)] { return x; }; // 返回 20

auto generator = [x = 0] () mutable {
  // 没有'mutable'将无法编译，因为我们在每次调用时修改x
  return x++;
};
auto a = generator(); // == 0
auto b = generator(); // == 1
auto c = generator(); // == 2
```
由于现在可以_移动_（或_转发_)值到lambda中，而之前只能通过拷贝或引用捕获，我们现在可以按值捕获仅移动类型。注意在下面的例子中，`task2`捕获列表中`=`左侧的`p`是lambda体私有的新变量，不引用原始的`p`。
```cpp
auto p = std::make_unique<int>(1);

auto task1 = [=] { *p = 5; }; // 错误：std::unique_ptr不能被拷贝
// 对比
auto task2 = [p = std::move(p)] { *p = 5; }; // 正确：p被移动构造到闭包对象中
// task2创建后原始p为空
```
使用这个特性，引用捕获可以有不同的名称。
```cpp
auto x = 1;
auto f = [&r = x, x = x * 10] {
  ++r;
  return r + x;
};
f(); // 设置x为2并返回12
```

### 返回类型推导
在C++14中使用 `auto` 返回类型，编译器会尝试为你推导类型。对于lambda，你现在可以使用 `auto` 推导其返回类型，这使得返回推导的引用或右值引用成为可能。
```cpp
// 推导返回类型为 `int`。
auto f(int i) {
 return i;
}
```
```cpp
template <typename T>
auto& f(T& t) {
  return t;
}

// 返回对推导类型的引用。
auto g = [](auto& x) -> auto& { return f(x); };
int y = 123;
int& z = g(y); // 对 `y` 的引用
```

### decltype(auto)
`decltype(auto)` 类型说明符也像 `auto` 一样推导类型。但是，它在推导返回类型时会保留引用和cv限定符，而 `auto` 不会。
```cpp
const int x = 0;
auto x1 = x; // int
decltype(auto) x2 = x; // const int
int y = 0;
int& y1 = y;
auto y2 = y1; // int
decltype(auto) y3 = y1; // int&
int&& z = 0;
auto z1 = std::move(z); // int
decltype(auto) z2 = std::move(z); // int&&
```
```cpp
// 注意：对泛型代码特别有用！

// 返回类型是 `int`。
auto f(const int& i) {
 return i;
}

// 返回类型是 `const int&`。
decltype(auto) g(const int& i) {
 return i;
}

int x = 123;
static_assert(std::is_same<const int&, decltype(f(x))>::value == 0);
static_assert(std::is_same<int, decltype(f(x))>::value == 1);
static_assert(std::is_same<const int&, decltype(g(x))>::value == 1);
```

另见：[`decltype (C++11)`](./C++11.md)。

### 放宽constexpr函数的限制
在C++11中，`constexpr` 函数体只能包含非常有限的语法，包括（但不限于）：`typedef`、`using` 和单个 `return` 语句。在C++14中，允许的语法集大大扩展，包括最常见的语法，如 `if` 语句、多个 `return`、循环等。
```cpp
constexpr int factorial(int n) {
  if (n <= 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}
factorial(5); // == 120
```

### 变量模板
C++14 允许变量被模板化：
```cpp
template<class T>
constexpr T pi = T(3.1415926535897932385);
template<class T>
constexpr T e  = T(2.7182818284590452353);
```

### [[deprecated]]属性
C++14 引入 `[[deprecated]]` 属性来指示某个单元（函数、类等）不推荐使用，可能会产生编译警告。如果提供了原因，它将包含在警告中。
```cpp
[[deprecated]]
void old_method();
[[deprecated("请使用new_method替代")]]
void legacy_method();
```

## C++14 库特性

### 标准库类型的用户定义字面量
标准库类型的新用户定义字面量，包括 `chrono` 和 `basic_string` 的新内置字面量。这些可以是 `constexpr`，意味着它们可以在编译时使用。这些字面量的一些用途包括编译时整数解析、二进制字面量和虚数字面量。
```cpp
using namespace std::chrono_literals;
auto day = 24h;
day.count(); // == 24
std::chrono::duration_cast<std::chrono::minutes>(day).count(); // == 1440
```

### 编译时整数序列
类模板 `std::integer_sequence` 表示编译时整数序列。有一些基于它的辅助工具：
* `std::make_integer_sequence<T, N>` - 创建类型为 `T` 的 `0, ..., N - 1` 序列。
* `std::index_sequence_for<T...>` - 将模板参数包转换为整数序列。

将数组转换为元组：
```cpp
template<typename Array, std::size_t... I>
decltype(auto) a2t_impl(const Array& a, std::integer_sequence<std::size_t, I...>) {
  return std::make_tuple(a[I]...);
}

template<typename T, std::size_t N, typename Indices = std::make_index_sequence<N>>
decltype(auto) a2t(const std::array<T, N>& a) {
  return a2t_impl(a, Indices());
}
```

### std::make_unique
`std::make_unique` 是创建 `std::unique_ptr` 实例的推荐方式，原因如下：
* 避免使用 `new` 运算符。
* 防止在指定指针应持有的底层类型时重复代码。
* 最重要的是，它提供异常安全。假设我们这样调用函数 `foo`：
```cpp
foo(std::unique_ptr<T>{new T{}}, function_that_throws(), std::unique_ptr<T>{new T{}});
```
编译器可以自由地先调用 `new T{}`，然后 `function_that_throws()`，等等...由于我们在第一次构造 `T` 时已在堆上分配了数据，这里引入了泄漏。使用 `std::make_unique`，我们获得了异常安全：
```cpp
foo(std::make_unique<T>(), function_that_throws(), std::make_unique<T>());
```

有关 `std::unique_ptr` 和 `std::shared_ptr` 的更多信息，请参阅[智能指针 (C++11)](README.md#智能指针)部分。

## 致谢
* [cppreference](http://en.cppreference.com/w/cpp) - 对于查找新库特性的示例和文档特别有用。
* [C++右值引用详解](http://web.archive.org/web/20240324121501/http://thbecker.net/articles/rvalue_references/section_01.html) - 我用来理解右值引用、完美转发和移动语义的优秀介绍。
* [clang](http://clang.llvm.org/cxx_status.html) 和 [gcc](https://gcc.gnu.org/projects/cxx-status.html) 的标准支持页面。这里还包括我用来帮助查找描述、它旨在修复的问题以及一些示例的语言/库特性提案。
* [Compiler explorer](https://godbolt.org/)
* [Scott Meyers的《Effective Modern C++》](https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996) - 强烈推荐的书籍！
* [Jason Turner的C++ Weekly](https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw) - 不错的C++相关视频集合。
* [我能对移动后的对象做什么？](http://stackoverflow.com/questions/7027523/what-can-i-do-with-a-moved-from-object)
* [decltype(auto)的一些用途？](http://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto)
