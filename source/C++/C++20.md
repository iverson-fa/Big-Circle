# C++20

## 概述

C++20 包含以下新语言特性：
- [协程](#协程)
- [概念](#概念)
- [三路比较](#三路比较)
- [指定初始化器](#指定初始化器)
- [Lambda 表达式的模板语法](#lambda-表达式的模板语法)
- [带初始化器的基于范围的 for 循环](#带初始化器的基于范围的-for-循环)
- [\[\[likely\]\] 和 \[\[unlikely\]\] 属性](#likely-和-unlikely-属性)
- [弃用隐式捕获 this](#弃用隐式捕获-this)
- [非类型模板参数中的类类型](#非类型模板参数中的类类型)
- [constexpr 虚函数](#constexpr-虚函数)
- [explicit(bool)](#explicitbool)
- [立即函数](#立即函数)
- [using enum](#using-enum)
- [参数包的 Lambda 捕获](#参数包的-lambda-捕获)
- [char8_t](#char8_t)
- [constinit](#constinit)
- [\_\_VA\_OPT\_\_](#__va_opt__)

C++20 包含以下新库特性：
- [概念库](#概念库)
- [格式化库](#格式化库)
- [同步缓冲输出流](#同步缓冲输出流)
- [std::span](#stdspan)
- [位操作](#位操作)
- [数学常量](#数学常量)
- [std::is_constant_evaluated](#stdis_constant_evaluated)
- [std::make_shared 支持数组](#stdmake_shared-支持数组)
- [字符串的 starts_with 和 ends_with 方法](#字符串的-starts_with-和-ends_with-方法)
- [检查关联容器是否包含元素](#检查关联容器是否包含元素)
- [std::bit_cast](#stdbit_cast)
- [std::midpoint](#stdmidpoint)
- [std::to_array](#stdto_array)
- [std::bind_front](#stdbind_front)
- [统一容器擦除](#统一容器擦除)
- [三路比较辅助函数](#三路比较辅助函数)
- [std::lexicographical_compare_three_way](#stdlexicographical_compare_three_way)

## C++20 语言特性

### 协程

> **注意：** 虽然这些示例说明了如何在基础层面使用协程，但在代码编译时会发生更多事情。这些示例并非旨在完整覆盖 C++20 的协程。由于标准库尚未提供 `generator` 和 `task` 类，我使用了 cppcoro 库来编译这些示例。

_协程_ 是一种特殊的函数，其执行可以被暂停和恢复。要定义协程，函数体中必须存在 `co_return`、`co_await` 或 `co_yield` 关键字。C++20 的协程是无栈的；除非被编译器优化掉，否则它们的状态分配在堆上。

协程的一个例子是 _生成器_ 函数，它在每次调用时产生（即生成）一个值：
```c++
generator<int> range(int start, int end) {
  while (start < end) {
    co_yield start;
    start++;
  }

  // 函数末尾隐式的 co_return：
  // co_return;
}

for (int n : range(0, 10)) {
  std::cout << n << std::endl;
}
```
上面的 `range` 生成器函数生成从 `start` 开始直到 `end`（不包括）的值，每个迭代步骤产生当前存储在 `start` 中的值。生成器在每次调用 `range` 时保持其状态（在这种情况下，调用是针对 for 循环中的每次迭代）。`co_yield` 接受给定的表达式，产生（即返回）其值，并在该点挂起协程。恢复时，在 `co_yield` 之后继续执行。

协程的另一个例子是 _任务_，它是一个异步计算，在等待任务时执行：
```c++
task<void> echo(socket s) {
  for (;;) {
    auto data = co_await s.async_read();
    co_await async_write(s, data);
  }

  // 函数末尾隐式的 co_return：
  // co_return;
}
```
在这个例子中，引入了 `co_await` 关键字。该关键字接受一个表达式，如果你等待的东西（在这种情况下是读或写）尚未就绪，则挂起执行，否则继续执行。（注意，在底层，`co_yield` 使用了 `co_await`。）

使用任务来惰性求值：
```c++
task<int> calculate_meaning_of_life() {
  co_return 42;
}

auto meaning_of_life = calculate_meaning_of_life();
// ...
co_await meaning_of_life; // == 42
```

### 概念
_概念_ 是命名的编译时谓词，用于约束类型。它们采用以下形式：
```
template < template-parameter-list >
concept concept-name = constraint-expression;
```
其中 `constraint-expression` 求值为一个 constexpr 布尔值。_约束_ 应该模拟语义要求，例如类型是否为数值类型或可哈希类型。如果给定类型不满足它所绑定的概念（即 `constraint-expression` 返回 `false`），则会导致编译错误。因为约束是在编译时求值的，所以它们可以提供更有意义的错误消息和运行时安全性。
```c++
// `T` 不受任何约束限制。
template <typename T>
concept always_satisfied = true;
// 将 `T` 限制为整数类型。
template <typename T>
concept integral = std::is_integral_v<T>;
// 将 `T` 限制为同时满足 `integral` 约束和有符号性。
template <typename T>
concept signed_integral = integral<T> && std::is_signed_v<T>;
// 将 `T` 限制为同时满足 `integral` 约束和 `signed_integral` 约束的否定。
template <typename T>
concept unsigned_integral = integral<T> && !signed_integral<T>;
```
强制执行概念有多种语法形式：
```c++
// 函数参数的形式：
// `T` 是受约束的类型模板参数。
template <my_concept T>
void f(T v);

// `T` 是受约束的类型模板参数。
template <typename T>
  requires my_concept<T>
void f(T v);

// `T` 是受约束的类型模板参数。
template <typename T>
void f(T v) requires my_concept<T>;

// `v` 是受约束的推导参数。
void f(my_concept auto v);

// `v` 是受约束的非类型模板参数。
template <my_concept auto v>
void g();

// 自动推导变量的形式：
// `foo` 是受约束的自动推导值。
my_concept auto foo = ...;

// Lambda 表达式的形式：
// `T` 是受约束的类型模板参数。
auto f = []<my_concept T> (T v) {
  // ...
};
// `T` 是受约束的类型模板参数。
auto f = []<typename T> requires my_concept<T> (T v) {
  // ...
};
// `T` 是受约束的类型模板参数。
auto f = []<typename T> (T v) requires my_concept<T> {
  // ...
};
// `v` 是受约束的推导参数。
auto f = [](my_concept auto v) {
  // ...
};
// `v` 是受约束的非类型模板参数。
auto g = []<my_concept auto v> () {
  // ...
};
```
`requires` 关键字用于启动 `requires` 子句或 `requires` 表达式：
```c++
template <typename T>
  requires my_concept<T> // `requires` 子句。
void f(T);

template <typename T>
concept callable = requires (T f) { f(); }; // `requires` 表达式。

template <typename T>
  requires requires (T x) { x + x; } // 同一行上的 `requires` 子句和表达式。
T add(T a, T b) {
  return a + b;
}
```
注意，`requires` 表达式中的参数列表是可选的。`requires` 表达式中的每个要求是以下之一：

* **简单要求** - 断言给定表达式是有效的。

```c++
template <typename T>
concept callable = requires (T f) { f(); };
```
* **类型要求** - 由 `typename` 关键字后跟类型名表示，断言给定的类型名是有效的。

```c++
struct foo {
  int foo;
};

struct bar {
  using value = int;
  value data;
};

struct baz {
  using value = int;
  value data;
};

// 使用 SFINAE，如果 `T` 是 `baz` 则启用。
template <typename T, typename = std::enable_if_t<std::is_same_v<T, baz>>>
struct S {};

template <typename T>
using Ref = T&;

template <typename T>
concept C = requires {
                     // 对类型 `T` 的要求：
  typename T::value; // A) 有一个名为 `value` 的内部成员
  typename S<T>;     // B) 必须对 `S` 有有效的类模板特化
  typename Ref<T>;   // C) 必须是有效的别名模板替换
};

template <C T>
void g(T a);

g(foo{}); // 错误：不满足要求 A。
g(bar{}); // 错误：不满足要求 B。
g(baz{}); // 通过。
```
* **复合要求** - 花括号中的表达式后跟尾随返回类型或类型约束。

```c++
template <typename T>
concept C = requires(T x) {
  {*x} -> std::convertible_to<typename T::inner>; // 表达式 `*x` 的类型可转换为 `T::inner`
  {x + 1} -> std::same_as<int>; // 表达式 `x + 1` 满足 `std::same_as<decltype((x + 1))>`
  {x * 1} -> std::convertible_to<T>; // 表达式 `x * 1` 的类型可转换为 `T`
};
```
* **嵌套要求** - 由 `requires` 关键字表示，指定额外的约束（例如对局部参数参数的约束）。

```c++
template <typename T>
concept C = requires(T x) {
  requires std::same_as<sizeof(x), size_t>;
};
```
另请参阅：[概念库](#概念库)。

### 三路比较
C++20 引入了太空船操作符（`<=>`）作为编写比较函数的新方法，可以减少样板代码并帮助开发人员定义更清晰的比较语义。定义三路比较运算符将自动生成其他比较运算符函数（即 `==`、`!=`、`<` 等）。

引入了三种排序：
* `std::strong_ordering`：强排序区分项是否相等（相同且可互换）。提供 `less`、`greater`、`equivalent` 和 `equal` 排序。比较示例：在列表中搜索特定值、整数值、区分大小写的字符串。
* `std::weak_ordering`：弱排序区分项是否等价（不相同，但为了比较的目的可以互换）。提供 `less`、`greater` 和 `equivalent` 排序。比较示例：不区分大小写的字符串、排序、比较类的部分可见成员。
* `std::partial_ordering`：部分排序遵循弱排序的相同原则，但包括排序不可能的情况。提供 `less`、`greater`、`equivalent` 和 `unordered` 排序。比较示例：浮点值（例如 `NaN`）。

默认的三路比较运算符进行成员逐一比较：
```c++
struct foo {
  int a;
  bool b;
  char c;

  // 先比较 `a`，然后 `b`，然后 `c` ...
  friend auto operator<=>(const foo&) const = default;
};

foo f1{0, false, 'a'}, f2{0, true, 'b'};
f1 < f2; // == true
f1 == f2; // == false
f1 >= f2; // == false
```

你也可以定义自己的比较：
```c++
struct foo {
  int x;
  bool b;
  char c;

  friend std::strong_ordering operator<=>(const foo& other) const {
      return x <=> other.x;
  }
};

foo f1{0, false, 'a'}, f2{0, true, 'b'};
f1 < f2; // == false
f1 == f2; // == true
f1 >= f2; // == true
```

### 指定初始化器
C 风格的指定初始化器语法。任何未在指定初始化器列表中明确列出的成员字段都将被默认初始化。
```c++
struct A {
  int x;
  int y;
  int z = 123;
};

A a {.x = 1, .z = 2}; // a.x == 1, a.y == 0, a.z == 2
```

### Lambda 表达式的模板语法
在 Lambda 表达式中使用熟悉的模板语法。
```c++
auto f = []<typename T>(std::vector<T> v) {
  // ...
};
```

### 带初始化器的基于范围的 for 循环
此特性简化了常见的代码模式，有助于保持作用域紧凑，并为常见的生命周期问题提供了优雅的解决方案。
```c++
for (auto v = std::vector{1, 2, 3}; auto& e : v) {
  std::cout << e;
}
// 打印 "123"
```

### \[\[likely\]\] 和 \[\[unlikely\]\] 属性
向优化器提示标记的语句有很高的概率被执行。
```c++
switch (n) {
case 1:
  // ...
  break;

[[likely]] case 2:  // n == 2 被认为比其他任何 n 值
  // ...            // 都更可能发生
  break;
}
```

如果 likely/unlikely 属性之一出现在 if 语句的右括号之后，它表示该分支很可能/不太可能执行其子语句（主体）。
```c++
int random = get_random_number_between_x_and_y(0, 3);
if (random > 0) [[likely]] {
  // if 语句的主体
  // ...
}
```

它也可以应用于迭代语句的子语句（主体）。
```c++
while (unlikely_truthy_condition) [[unlikely]] {
  // while 语句的主体
  // ...
}
```

### 弃用隐式捕获 this
现在不推荐使用 `[=]` 在 Lambda 捕获中隐式捕获 `this`；建议使用 `[=, this]` 或 `[=, *this]` 显式捕获。
```c++
struct int_value {
  int n = 0;
  auto getter_fn() {
    // 不好：
    // return [=]() { return n; };

    // 好：
    return [=, *this]() { return n; };
  }
};
```

### 非类型模板参数中的类类型
类现在可以在非类型模板参数中使用。作为模板参数传递的对象具有 `const T` 类型，其中 `T` 是对象的类型，并且具有静态存储期。
```c++
struct foo {
  foo() = default;
  constexpr foo(int) {}
};

template <foo f = {}>
auto get_foo() {
  return f;
}

get_foo(); // 使用隐式构造函数
get_foo<foo{123}>();
```

### constexpr 虚函数
虚函数现在可以是 `constexpr` 并在编译时求值。`constexpr` 虚函数可以重写非 `constexpr` 虚函数，反之亦然。
```c++
struct X1 {
  virtual int f() const = 0;
};

struct X2: public X1 {
  constexpr virtual int f() const { return 2; }
};

struct X3: public X2 {
  virtual int f() const { return 3; }
};

struct X4: public X3 {
  constexpr virtual int f() const { return 4; }
};

constexpr X4 x4;
x4.f(); // == 4
```

### explicit(bool)
在编译时有条件地选择是否将构造函数设为 explicit。`explicit(true)` 与指定 `explicit` 相同。
```c++
struct foo {
  // 指定非整型类型（字符串、浮点数等）需要显式构造。
  template <typename T>
  explicit(!std::is_integral_v<T>) foo(T) {}
};

foo a = 123; // 正确
foo b = "123"; // 错误：显式构造函数不是候选（explicit 说明符求值为 true）
foo c {"123"}; // 正确
```

### 立即函数
类似于 `constexpr` 函数，但带有 `consteval` 说明符的函数必须产生常量。这些函数称为`立即函数`。
```c++
consteval int sqr(int n) {
  return n * n;
}

constexpr int r = sqr(100); // 正确
int x = 100;
int r2 = sqr(x); // 错误：'x' 的值不能在常量表达式中使用
                 // 如果 `sqr` 是 `constexpr` 函数则正确
```

### using enum
将枚举的成员引入作用域以提高可读性。之前：
```c++
enum class rgba_color_channel { red, green, blue, alpha };

std::string_view to_string(rgba_color_channel channel) {
  switch (channel) {
    case rgba_color_channel::red:   return "red";
    case rgba_color_channel::green: return "green";
    case rgba_color_channel::blue:  return "blue";
    case rgba_color_channel::alpha: return "alpha";
  }
}
```
之后：
```c++
enum class rgba_color_channel { red, green, blue, alpha };

std::string_view to_string(rgba_color_channel my_channel) {
  switch (my_channel) {
    using enum rgba_color_channel;
    case red:   return "red";
    case green: return "green";
    case blue:  return "blue";
    case alpha: return "alpha";
  }
}
```

### 参数包的 Lambda 捕获
按值捕获参数包：
```c++
template <typename... Args>
auto f(Args&&... args){
    // 按值：
    return [...args = std::forward<Args>(args)] {
        // ...
    };
}
```
按引用捕获参数包：
```c++
template <typename... Args>
auto f(Args&&... args){
    // 按引用：
    return [&...args = std::forward<Args>(args)] {
        // ...
    };
}
```

### char8_t
提供用于表示 UTF-8 字符串的标准类型。
```c++
char8_t utf8_str[] = u8"\u0123";
```

### constinit
`constinit` 说明符要求变量必须在编译时初始化。
```c++
const char* g() { return "dynamic initialization"; }
constexpr const char* f(bool p) { return p ? "constant initializer" : g(); }

constinit const char* c = f(true); // 正确
constinit const char* d = g(false); // 错误：`g` 不是 constexpr，因此 `d` 无法在编译时求值。
```

### \_\_VA\_OPT\_\_
通过求值为给定参数（如果可变参数宏非空）来帮助支持可变参数宏。
```c++
#define F(...) f(0 __VA_OPT__(,) __VA_ARGS__)
F(a, b, c) // 替换为 f(0, a, b, c)
F()        // 替换为 f(0)
```

## C++20 库特性

### 概念库
标准库也提供了概念用于构建更复杂的概念。其中一些包括：

**核心语言概念：**
- `same_as` - 指定两种类型相同。
- `derived_from` - 指定一个类型派生自另一个类型。
- `convertible_to` - 指定一个类型可隐式转换为另一个类型。
- `common_with` - 指定两种类型共享一个公共类型。
- `integral` - 指定一个类型是整数类型。
- `default_constructible` - 指定可以默认构造一个类型的对象。

 **比较概念：**
- `boolean` - 指定一个类型可用于布尔上下文。
- `equality_comparable` - 指定 `operator==` 是等价关系。

 **对象概念：**
- `movable` - 指定可以移动和交换一个类型的对象。
- `copyable` - 指定可以复制、移动和交换一个类型的对象。
- `semiregular` - 指定可以复制、移动、交换和默认构造一个类型的对象。
- `regular` - 指定一个类型是 _正则的_，即它既是 `semiregular` 又是 `equality_comparable`。

 **可调用概念：**
- `invocable` - 指定可以使用一组给定的参数类型调用可调用类型。
- `predicate` - 指定可调用类型是布尔谓词。

另请参阅：[概念](#概念)。

### 格式化库
结合了 `printf` 的简单性和 `iostream` 的类型安全性。使用大括号作为占位符，并支持类似于 printf 风格说明符的自定义格式化。
```c++
std::format("{1} {0}", "world", "hello"); // == "hello world"

int x = 123;
std::string str = std::format("x: {}", x); // str == "x: 123"

// 格式化到输出迭代器：
for (auto x : {1, 2, 3}) {
  std::format_to(std::ostream_iterator<char>{std::cout, "\n"}, "{}", x);
}
```

要格式化自定义类型：
```c++
struct fraction {
  int numerator;
  int denominator;
};

template <>
struct std::formatter<fraction>
{
    constexpr auto parse(std::format_parse_context& ctx) {
      return ctx.begin();
    }

    auto format(const fraction& f, std::format_context& ctx) const {
      return std::format_to(ctx.out(), "{0:d}/{1:d}", f.numerator, f.denominator);
    }
};

fraction f{1, 2};
std::format("{}", f); // == "1/2"
```

### 同步缓冲输出流
缓冲包装输出流的输出操作，确保同步（即输出不会交错）。
```c++
std::osyncstream{std::cout} << "The value of x is:" << x << std::endl;
```

### std::span
span 是容器的视图（即非拥有），提供对连续元素组的边界检查访问。由于视图不拥有其元素，因此构造和复制成本很低——关于视图的一种简化理解是它们持有对其数据的引用。与维护指针/迭代器和长度字段相反，span 将两者包装在单个对象中。

span 可以是动态大小的或固定大小的（称为其*范围*）。固定大小的 span 受益于边界检查。

Span 不传播 const，因此要构造只读 span，请使用 `std::span<const T>`。

示例：使用动态大小的 span 打印来自各种容器的整数。
```c++
void print_ints(std::span<const int> ints) {
    for (const auto n : ints) {
        std::cout << n << std::endl;
    }
}

print_ints(std::vector{ 1, 2, 3 });
print_ints(std::array<int, 5>{ 1, 2, 3, 4, 5 });

int a[10] = { 0 };
print_ints(a);
// 等等。
```

示例：静态大小的 span 对于与 span 范围不匹配的容器将无法编译。
```c++
void print_three_ints(std::span<const int, 3> ints) {
    for (const auto n : ints) {
        std::cout << n << std::endl;
    }
}

print_three_ints(std::vector{ 1, 2, 3 }); // 错误
print_three_ints(std::array<int, 5>{ 1, 2, 3, 4, 5 }); // 错误
int a[10] = { 0 };
print_three_ints(a); // 错误

std::array<int, 3> b = { 1, 2, 3 };
print_three_ints(b); // 正确

// 如果需要，可以手动构造 span：
std::vector c{ 1, 2, 3 };
print_three_ints(std::span<const int, 3>{ c.data(), 3 }); // 正确：设置指针和长度字段。
print_three_ints(std::span<const int, 3>{ c.cbegin(), c.cend() }); // 正确：使用迭代器对。
```

### 位操作
C++20 提供了一个新的 `<bit>` 头文件，提供了一些位操作，包括 popcount。
```c++
std::popcount(0u); // 0
std::popcount(1u); // 1
std::popcount(0b1111'0000u); // 4
```

### 数学常量
数学常量，包括 PI、欧拉数等，定义在 `<numbers>` 头文件中。
```c++
std::numbers::pi; // 3.14159...
std::numbers::e; // 2.71828...
```

### std::is_constant_evaluated
谓词函数，当在编译时上下文中调用时为真。
```c++
constexpr bool is_compile_time() {
    return std::is_constant_evaluated();
}

constexpr bool a = is_compile_time(); // true
bool b = is_compile_time(); // false
```

### std::make_shared 支持数组
```c++
auto p = std::make_shared<int[]>(5); // 指向 `int[5]` 的指针
// 或者
auto p = std::make_shared<int[5]>(); // 指向 `int[5]` 的指针
```

### 字符串的 starts_with 和 ends_with 方法
字符串（和字符串视图）现在有 `starts_with` 和 `ends_with` 成员函数来检查字符串是否以给定字符串开头或结尾。
```c++
std::string str = "foobar";
str.starts_with("foo"); // true
str.ends_with("baz"); // false
```

### 检查关联容器是否包含元素
关联容器（如集合和映射）有一个 `contains` 成员函数，可以用来代替“查找并检查迭代器末尾”的习惯用法。
```c++
std::map<int, char> map {{1, 'a'}, {2, 'b'}};
map.contains(2); // true
map.contains(123); // false

std::set<int> set {1, 2, 3};
set.contains(2); // true
```

### std::bit_cast
一种更安全的方式将对象从一种类型重新解释为另一种类型。
```c++
float f = 123.0;
int i = std::bit_cast<int>(f);
```

### std::midpoint
安全地计算两个整数的中点（无溢出）。
```c++
std::midpoint(1, 3); // == 2
```

### std::to_array
将给定的数组/“类数组”对象转换为 `std::array`。
```c++
std::to_array("foo"); // 返回 `std::array<char, 4>`
std::to_array<int>({1, 2, 3}); // 返回 `std::array<int, 3>`

int a[] = {1, 2, 3};
std::to_array(a); // 返回 `std::array<int, 3>`
```

### std::bind_front
将前 N 个参数（其中 N 是给定函数后 `std::bind_front` 的参数数量）绑定到给定的自由函数、lambda 或成员函数。
```c++
const auto f = [](int a, int b, int c) { return a + b + c; };
const auto g = std::bind_front(f, 1, 1);
g(1); // == 3
```

### 统一容器擦除
为各种 STL 容器（如 string、list、vector、map 等）提供 `std::erase` 和/或 `std::erase_if`。

要按值擦除使用 `std::erase`，或者要指定何时擦除元素的谓词使用 `std::erase_if`。两个函数都返回被擦除的元素数量。

```c++
std::vector v{0, 1, 0, 2, 0, 3};
std::erase(v, 0); // v == {1, 2, 3}
std::erase_if(v, [](int n) { return n == 0; }); // v == {1, 2, 3}
```

### 三路比较辅助函数
为比较结果命名的辅助函数：
```c++
std::is_eq(0 <=> 0); // == true
std::is_lteq(0 <=> 1); // == true
std::is_gt(0 <=> 1); // == false
```

另请参阅：[三路比较](#三路比较)。

### std::lexicographical_compare_three_way
使用三路比较对两个范围进行字典序比较，并产生最强适用比较类别类型的结果。
```c++
std::vector a{0, 0, 0}, b{0, 0, 0}, c{1, 1, 1};

auto cmp_ab = std::lexicographical_compare_three_way(
    a.begin(), a.end(), b.begin(), b.end());
std::is_eq(cmp_ab); // == true

auto cmp_ac = std::lexicographical_compare_three_way(
    a.begin(), a.end(), c.begin(), c.end());
std::is_lt(cmp_ac); // == true
```

另请参阅：[三路比较](#三路比较)，[三路比较辅助函数](#三路比较辅助函数)。

## 致谢
* [cppreference](http://en.cppreference.com/w/cpp) - 对于查找新库特性的示例和文档特别有用。
* [C++ Rvalue References Explained](http://web.archive.org/web/20240324121501/http://thbecker.net/articles/rvalue_references/section_01.html) - 我用来理解右值引用、完美转发和移动语义的优秀介绍。
* [clang](http://clang.llvm.org/cxx_status.html) 和 [gcc](https://gcc.gnu.org/projects/cxx-status.html) 的标准支持页面。这里还包括我用来帮助查找描述、它旨在修复的问题以及一些示例的语言/库特性的提案。
* [Compiler explorer](https://godbolt.org/)
* [Scott Meyers' Effective Modern C++](https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996) - 强烈推荐的书！
* [Jason Turner's C++ Weekly](https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw) - 不错的 C++ 相关视频集合。
* [What can I do with a moved-from object?](http://stackoverflow.com/questions/7027523/what-can-i-do-with-a-moved-from-object)
* [What are some uses of decltype(auto)?](http://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto)