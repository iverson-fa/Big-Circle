# C++11

## 概述

C++11 包含以下新的语言特性：
- [移动语义](#移动语义)
- [可变参数模板](#可变参数模板)
- [右值引用](#右值引用)
- [转发引用](#转发引用)
- [初始化列表](#初始化列表)
- [静态断言](#静态断言)
- [auto](#auto)
- [Lambda 表达式](#lambda-表达式)
- [decltype](#decltype)
- [类型别名](#类型别名)
- [nullptr](#nullptr)
- [强类型枚举](#强类型枚举)
- [属性](#属性)
- [constexpr](#constexpr)
- [委托构造函数](#委托构造函数)
- [用户定义字面量](#用户定义字面量)
- [显式虚函数重写](#显式虚函数重写)
- [final 说明符](#final-说明符)
- [默认函数](#默认函数)
- [删除函数](#删除函数)
- [基于范围的 for 循环](#基于范围的-for-循环)
- [用于移动语义的特殊成员函数](#用于移动语义的特殊成员函数)
- [转换构造函数](#转换构造函数)
- [显式转换函数](#显式转换函数)
- [内联命名空间](#内联命名空间)
- [非静态数据成员初始化器](#非静态数据成员初始化器)
- [右尖括号](#右尖括号)
- [引用限定成员函数](#引用限定成员函数)
- [尾随返回类型](#尾随返回类型)
- [noexcept 说明符](#noexcept-说明符)
- [char32_t 和 char16_t](#char32_t-和-char16_t)
- [原始字符串字面量](#原始字符串字面量)

C++11 包含以下新的库特性：
- [std::move](#stdmove)
- [std::forward](#stdforward)
- [std::thread](#stdthread)
- [std::to_string](#stdto_string)
- [类型特征](#类型特征)
- [智能指针](#智能指针)
- [std::chrono](#stdchrono)
- [元组](#元组)
- [std::tie](#stdtie)
- [std::array](#stdarray)
- [无序容器](#无序容器)
- [std::make_shared](#stdmake_shared)
- [std::ref](#stdref)
- [内存模型](#内存模型)
- [std::async](#stdasync)
- [std::begin/end](#stdbeginend)

## C++11 语言特性

### 移动语义
移动一个对象意味着将其管理的某些资源的所有权转移给另一个对象。

移动语义的第一个好处是性能优化。当一个对象即将到达其生命周期的尽头时（可能是因为它是一个临时对象，或者通过显式调用 `std::move`），移动通常是转移资源的一种更廉价的方式。例如，移动一个 `std::vector` 只是将一些指针和内部状态复制到新的 vector 中——而复制则需要复制 vector 中的每个包含的元素，这是昂贵的，并且如果旧的 vector 即将被销毁，则是不必要的。

移动还使得不可复制的类型（例如 `std::unique_ptr`（[智能指针](#智能指针)））能够在语言级别保证一次只有一个资源实例被管理，同时能够在作用域之间转移实例。

请参阅相关章节：[右值引用](#右值引用), [用于移动语义的特殊成员函数](#用于移动语义的特殊成员函数), [`std::move`](#stdmove), [`std::forward`](#stdforward), [`转发引用`](#转发引用)。

### 右值引用
C++11 引入了一种新的引用，称为*右值引用*。一个指向 `T` 的右值引用（`T` 是非模板类型参数，如 `int` 或用户定义类型）使用语法 `T&&` 创建。右值引用只绑定到右值。

左值和右值的类型推导：
```c++
int x = 0; // `x` 是类型为 `int` 的左值
int& xl = x; // `xl` 是类型为 `int&` 的左值
int&& xr = x; // 编译器错误 -- `x` 是左值
int&& xr2 = 0; // `xr2` 是类型为 `int&&` 的左值 -- 绑定到右值临时量 `0`

void f(int& x) {}
void f(int&& x) {}

f(x);  // 调用 f(int&)
f(xl); // 调用 f(int&)
f(3);  // 调用 f(int&&)
f(std::move(x)); // 调用 f(int&&)

f(xr2);           // 调用 f(int&)
f(std::move(xr2)); // 调用 f(int&& x)
```

另请参阅：[`std::move`](#stdmove), [`std::forward`](#stdforward), [`转发引用`](#转发引用)。

### 转发引用
也称为（非官方）*通用引用*。转发引用使用语法 `T&&` 创建，其中 `T` 是模板类型参数，或者使用 `auto&&`。这实现了*完美转发*：能够在传递参数时保持其值类别（例如，左值保持为左值，临时量作为右值转发）。

转发引用允许引用根据类型绑定到左值或右值。转发引用遵循*引用折叠*规则：
* `T& &` 变为 `T&`
* `T& &&` 变为 `T&`
* `T&& &` 变为 `T&`
* `T&& &&` 变为 `T&&`

使用左值和右值的 `auto` 类型推导：
```c++
int x = 0; // `x` 是类型为 `int` 的左值
auto&& al = x; // `al` 是类型为 `int&` 的左值 -- 绑定到左值 `x`
auto&& ar = 0; // `ar` 是类型为 `int&&` 的左值 -- 绑定到右值临时量 `0`
```

使用左值和右值的模板类型参数推导：
```c++
// C++14 或更新版本：
void f(auto&& t) {
  // ...
}

// C++11 或更新版本：
template <typename T>
void f(T&& t) {
  // ...
}

int x = 0;
f(0); // T 是 int, 推导为 f(int &&) => f(int&&)
f(x); // T 是 int&, 推导为 f(int& &&) => f(int&)

int& y = x;
f(y); // T 是 int&, 推导为 f(int& &&) => f(int&)

int&& z = 0; // 注意：`z` 是类型为 `int&&` 的左值。
f(z); // T 是 int&, 推导为 f(int& &&) => f(int&)
f(std::move(z)); // T 是 int, 推导为 f(int &&) => f(int&&)
```

另请参阅：[`std::move`](#stdmove), [`std::forward`](#stdforward), [`右值引用`](#右值引用)。

### 可变参数模板
`...` 语法创建一个*参数包*或展开一个参数包。模板*参数包*是一个接受零个或多个模板参数（非类型、类型或模板）的模板参数。至少有一个参数包的模板称为*可变参数模板*。
```c++
template <typename... T>
struct arity {
  constexpr static int value = sizeof...(T);
};
static_assert(arity<>::value == 0);
static_assert(arity<char, short, int>::value == 3);
```

一个有趣的用法是从*参数包*创建*初始化列表*，以便遍历可变函数参数。
```c++
template <typename First, typename... Args>
auto sum(const First first, const Args... args) -> decltype(first) {
  const auto values = {first, args...};
  return std::accumulate(values.begin(), values.end(), First{0});
}

sum(1, 2, 3, 4, 5); // 15
sum(1, 2, 3);       // 6
sum(1.5, 2.0, 3.7); // 7.2
```

### 初始化列表
使用"大括号列表"语法创建的元素的轻量级类似数组的容器。例如，`{ 1, 2, 3 }` 创建一个整数序列，其类型为 `std::initializer_list<int>`。可用作将对象向量传递给函数的替代方法。
```c++
int sum(const std::initializer_list<int>& list) {
  int total = 0;
  for (auto& e : list) {
    total += e;
  }

  return total;
}

auto list = {1, 2, 3};
sum(list); // == 6
sum({1, 2, 3}); // == 6
sum({}); // == 0
```

### 静态断言
在编译时计算的断言。
```c++
constexpr int x = 0;
constexpr int y = 1;
static_assert(x == y, "x != y");
```

### auto
`auto` 类型的变量由编译器根据其初始化器的类型推导得出。
```c++
auto a = 3.14; // double
auto b = 1; // int
auto& c = b; // int&
auto d = { 0 }; // std::initializer_list<int>
auto&& e = 1; // int&&
auto&& f = b; // int&
auto g = new auto(123); // int*
const auto h = 1; // const int
auto i = 1, j = 2, k = 3; // int, int, int
auto l = 1, m = true, n = 1.61; // 错误 -- `l` 推导为 int, `m` 是 bool
auto o; // 错误 -- `o` 需要初始化器
```

对于提高可读性非常有用，特别是对于复杂类型：
```c++
std::vector<int> v = ...;
std::vector<int>::const_iterator cit = v.cbegin();
// 对比
auto cit = v.cbegin();
```

函数也可以使用 `auto` 推导返回类型。在 C++11 中，返回类型必须显式指定，或者像这样使用 `decltype`：
```c++
template <typename X, typename Y>
auto add(X x, Y y) -> decltype(x + y) {
  return x + y;
}
add(1, 2); // == 3
add(1, 2.0); // == 3.0
add(1.5, 1.5); // == 3.0
```
上面例子中的尾随返回类型是表达式 `x + y` 的*声明类型*（参见 [`decltype`](#decltype) 部分）。例如，如果 `x` 是整数，`y` 是双精度浮点数，则 `decltype(x + y)` 是双精度浮点数。因此，上述函数将根据表达式 `x + y` 产生的类型来推导类型。注意，尾随返回类型可以访问其参数，以及在适当时访问 `this`。

### Lambda 表达式
`lambda` 是一个能够捕获作用域中变量的无名函数对象。它的特点包括：一个*捕获列表*；一组可选的参数和一个可选的尾随返回类型；以及一个函数体。捕获列表示例：
* `[]` - 不捕获任何东西。
* `[=]` - 通过值捕获作用域中的局部对象（局部变量、参数）。
* `[&]` - 通过引用捕获作用域中的局部对象（局部变量、参数）。
* `[this]` - 通过引用捕获 `this`。
* `[a, &b]` - 通过值捕获对象 `a`，通过引用捕获 `b`。

```c++
int x = 1;

auto getX = [=] { return x; };
getX(); // == 1

auto addX = [=](int y) { return x + y; };
addX(1); // == 2

auto getXRef = [&]() -> int& { return x; };
getXRef(); // 对 `x` 的 int& 引用
```
默认情况下，值捕获不能在 lambda 内部修改，因为编译器生成的方法被标记为 `const`。`mutable` 关键字允许修改捕获的变量。该关键字放在参数列表之后（即使为空也必须存在）。
```c++
int x = 1;

auto f1 = [&x] { x = 2; }; // 正确：x 是引用并修改原始值

auto f2 = [x] { x = 2; }; // 错误：lambda 只能对捕获的值执行常量操作
// 对比
auto f3 = [x]() mutable { x = 2; }; // 正确：lambda 可以对捕获的值执行任何操作
```

### decltype
`decltype` 是一个操作符，它返回传递给它的表达式的*声明类型*。如果 cv 限定符和引用是表达式的一部分，则它们会被保留。`decltype` 示例：
```c++
int a = 1; // `a` 被声明为类型 `int`
decltype(a) b = a; // `decltype(a)` 是 `int`
const int& c = a; // `c` 被声明为类型 `const int&`
decltype(c) d = a; // `decltype(c)` 是 `const int&`
decltype(123) e = 123; // `decltype(123)` 是 `int`
int&& f = 1; // `f` 被声明为类型 `int&&`
decltype(f) g = 1; // `decltype(f) 是 `int&&`
decltype((a)) h = g; // `decltype((a))` 是 int&
```
```c++
template <typename X, typename Y>
auto add(X x, Y y) -> decltype(x + y) {
  return x + y;
}
add(1, 2.0); // `decltype(x + y)` => `decltype(3.0)` => `double`
```

另请参阅：[`decltype(auto) (C++14)`](README.md#decltypeauto)。

### 类型别名
在语义上类似于使用 `typedef`，但是，使用 `using` 的类型别名更易于阅读并且与模板兼容。
```c++
template <typename T>
using Vec = std::vector<T>;
Vec<int> v; // std::vector<int>

using String = std::string;
String s {"foo"};
```

### nullptr
C++11 引入了一种新的空指针类型，旨在替代 C 的 `NULL` 宏。`nullptr` 本身的类型是 `std::nullptr_t`，可以隐式转换为指针类型，并且与 `NULL` 不同，除了 `bool` 之外不能转换为整型。
```c++
void foo(int);
void foo(char*);
foo(NULL); // 错误 -- 歧义
foo(nullptr); // 调用 foo(char*)
```

### 强类型枚举
类型安全的枚举，解决了 C 风格枚举的各种问题，包括：隐式转换、无法指定底层类型、作用域污染。
```c++
// 指定底层类型为 `unsigned int`
enum class Color : unsigned int { Red = 0xff0000, Green = 0xff00, Blue = 0xff };
// `Alert` 中的 `Red`/`Green` 不会与 `Color` 冲突
enum class Alert : bool { Red, Green };
Color c = Color::Red;
```

### 属性
属性提供了超越 `__attribute__(...)`、`__declspec` 等的通用语法。
```c++
// `noreturn` 属性表明 `f` 不会返回。
[[ noreturn ]] void f() {
  throw "error";
}
```

### constexpr
常量表达式是*可能*由编译器在编译时求值的表达式。只有非复杂的计算可以在常量表达式中执行（这些规则在后续版本中逐步放宽）。使用 `constexpr` 说明符来指示变量、函数等是常量表达式。
```c++
constexpr int square(int x) {
  return x * x;
}

int square2(int x) {
  return x * x;
}

int a = square(2);  // mov DWORD PTR [rbp-4], 4

int b = square2(2); // mov edi, 2
                    // call square2(int)
                    // mov DWORD PTR [rbp-8], eax
```
在前面的代码片段中，注意调用 `square` 时的计算是在编译时进行的，然后结果被嵌入到代码生成中，而 `square2` 是在运行时调用的。

`constexpr` 值是编译器可以（但不保证）在编译时求值的值：
```c++
const int x = 123;
constexpr const int& y = x; // 错误 -- constexpr 变量 `y` 必须由常量表达式初始化
```

类的常量表达式：
```c++
struct Complex {
  constexpr Complex(double r, double i) : re{r}, im{i} { }
  constexpr double real() { return re; }
  constexpr double imag() { return im; }

private:
  double re;
  double im;
};

constexpr Complex I(0, 1);
```

### 委托构造函数
构造函数现在可以使用初始化列表调用同一类中的其他构造函数。
```c++
struct Foo {
  int foo;
  Foo(int foo) : foo{foo} {}
  Foo() : Foo(0) {}
};

Foo foo;
foo.foo; // == 0
```

### 用户定义字面量
用户定义字面量允许您扩展语言并添加自己的语法。要创建字面量，定义一个返回类型 `T`、名称为 `X` 的 `T operator "" X(...) { ... }` 函数。注意，此函数的名称定义了字面量的名称。任何不以 underscore 开头的字面量名称都是保留的，不会被调用。根据调用字面量的类型，用户定义字面量函数应接受哪些参数有相应的规则。

将摄氏度转换为华氏度：
```c++
// 整数字面量需要 `unsigned long long` 参数。
long long operator "" _celsius(unsigned long long tempCelsius) {
  return std::llround(tempCelsius * 1.8 + 32);
}
24_celsius; // == 75
```

字符串到整数的转换：
```c++
// 需要 `const char*` 和 `std::size_t` 作为参数。
int operator "" _int(const char* str, std::size_t) {
  return std::stoi(str);
}

"123"_int; // == 123, 类型为 `int`
```

### 显式虚函数重写
指定虚函数重写另一个虚函数。如果虚函数没有重写父类的虚函数，则抛出编译器错误。
```c++
struct A {
  virtual void foo();
  void bar();
};

struct B : A {
  void foo() override; // 正确 -- B::foo 重写 A::foo
  void bar() override; // 错误 -- A::bar 不是虚函数
  void baz() override; // 错误 -- B::baz 没有重写 A::baz
};
```

### Final 说明符
指定虚函数不能在派生类中被重写，或者类不能被继承。
```c++
struct A {
  virtual void foo();
};

struct B : A {
  virtual void foo() final;
};

struct C : B {
  virtual void foo(); // 错误 -- 'foo' 的声明重写了 'final' 函数
};
```

类不能被继承。
```c++
struct A final {};
struct B : A {}; // 错误 -- 基类 'A' 被标记为 'final'
```

### 默认函数
一种更优雅、高效的方式来提供函数的默认实现，例如构造函数。
```c++
struct A {
  A() = default;
  A(int x) : x{x} {}
  int x {1};
};
A a; // a.x == 1
A a2 {123}; // a.x == 123
```

继承情况：
```c++
struct B {
  B() : x{1} {}
  int x;
};

struct C : B {
  // 调用 B::B
  C() = default;
};

C c; // c.x == 1
```

### 删除函数
一种更优雅、高效的方式来提供函数的已删除实现。对于防止对象复制非常有用。
```c++
class A {
  int x;

public:
  A(int x) : x{x} {};
  A(const A&) = delete;
  A& operator=(const A&) = delete;
};

A x {123};
A y = x; // 错误 -- 调用了已删除的拷贝构造函数
y = x; // 错误 -- operator= 已删除
```

### 基于范围的 for 循环
用于遍历容器元素的语法糖。
```c++
std::array<int, 5> a {1, 2, 3, 4, 5};
for (int& x : a) x *= 2;
// a == { 2, 4, 6, 8, 10 }
```

注意使用 `int` 与使用 `int&` 的区别：
```c++
std::array<int, 5> a {1, 2, 3, 4, 5};
for (int x : a) x *= 2;
// a == { 1, 2, 3, 4, 5 }
```

### 用于移动语义的特殊成员函数
当进行复制时会调用拷贝构造函数和拷贝赋值运算符，随着 C++11 引入移动语义，现在有了移动构造函数和移动赋值运算符用于移动。
```c++
struct A {
  std::string s;
  A() : s{"test"} {}
  A(const A& o) : s{o.s} {}
  A(A&& o) : s{std::move(o.s)} {}
  A& operator=(A&& o) {
   s = std::move(o.s);
   return *this;
  }
};

A f(A a) {
  return a;
}

A a1 = f(A{}); // 从右值临时量移动构造
A a2 = std::move(a1); // 使用 std::move 移动构造
A a3 = A{};
a2 = std::move(a3); // 使用 std::move 移动赋值
a1 = f(A{}); // 从右值临时量移动赋值
```

### 转换构造函数
转换构造函数将大括号列表语法中的值转换为构造函数参数。
```c++
struct A {
  A(int) {}
  A(int, int) {}
  A(int, int, int) {}
};

A a {0, 0}; // 调用 A::A(int, int)
A b(0, 0); // 调用 A::A(int, int)
A c = {0, 0}; // 调用 A::A(int, int)
A d {0, 0, 0}; // 调用 A::A(int, int, int)
```

注意大括号列表语法不允许窄化转换：
```c++
struct A {
  A(int) {}
};

A a(1.1); // OK
A b {1.1}; // 错误 从 double 到 int 的窄化转换
```

注意，如果构造函数接受 `std::initializer_list`，则将调用它：
```c++
struct A {
  A(int) {}
  A(int, int) {}
  A(int, int, int) {}
  A(std::initializer_list<int>) {}
};

A a {0, 0}; // 调用 A::A(std::initializer_list<int>)
A b(0, 0); // 调用 A::A(int, int)
A c = {0, 0}; // 调用 A::A(std::initializer_list<int>)
A d {0, 0, 0}; // 调用 A::A(std::initializer_list<int>)
```

### 显式转换函数
转换函数现在可以使用 `explicit` 说明符使其显式。
```c++
struct A {
  operator bool() const { return true; }
};

struct B {
  explicit operator bool() const { return true; }
};

A a;
if (a); // OK 调用 A::operator bool()
bool ba = a; // OK 拷贝初始化选择 A::operator bool()

B b;
if (b); // OK 调用 B::operator bool()
bool bb = b; // 错误 拷贝初始化不考虑 B::operator bool()
```
### 内联命名空间
内联命名空间的所有成员都被视为其父命名空间的一部分，允许函数的特化和简化版本控制过程。这是一个传递属性，如果 A 包含 B，而 B 又包含 C，并且 B 和 C 都是内联命名空间，则 C 的成员可以像在 A 上一样使用。

```c++
namespace Program {
  namespace Version1 {
    int getVersion() { return 1; }
    bool isFirstVersion() { return true; }
  }
  inline namespace Version2 {
    int getVersion() { return 2; }
  }
}

int version {Program::getVersion()};              // 使用 Version2 的 getVersion()
int oldVersion {Program::Version1::getVersion()}; // 使用 Version1 的 getVersion()
bool firstVersion {Program::isFirstVersion()};    // 当添加 Version2 时无法编译
```

### 非静态数据成员初始化器
允许在声明非静态数据成员的地方对它们进行初始化，从而可能清理构造函数的默认初始化。

```c++
// C++11 之前的默认初始化
class Human {
    Human() : age{0} {}
  private:
    unsigned age;
};
// C++11 的默认初始化
class Human {
  private:
    unsigned age {0};
};
```

### 右尖括号
C++11 现在能够推断出一系列右尖括号是作为运算符使用还是作为 typedef 的结束语句，而无需添加空格。

```c++
typedef std::map<int, std::map <int, std::map <int, int> > > cpp98LongTypedef;
typedef std::map<int, std::map <int, std::map <int, int>>>   cpp11LongTypedef;
```

### 引用限定成员函数
现在可以根据 `*this` 是左值引用还是右值引用来限定成员函数。

```c++
struct Bar {
  // ...
};

struct Foo {
  Bar& getBar() & { return bar; }
  const Bar& getBar() const& { return bar; }
  Bar&& getBar() && { return std::move(bar); }
  const Bar&& getBar() const&& { return std::move(bar); }
private:
  Bar bar;
};

Foo foo{};
Bar bar = foo.getBar(); // 调用 `Bar& getBar() &`

const Foo foo2{};
Bar bar2 = foo2.getBar(); // 调用 `Bar& Foo::getBar() const&`

Foo{}.getBar(); // 调用 `Bar&& Foo::getBar() &&`
std::move(foo).getBar(); // 调用 `Bar&& Foo::getBar() &&`
std::move(foo2).getBar(); // 调用 `const Bar&& Foo::getBar() const&`
```

### 尾随返回类型
C++11 允许函数和 lambda 使用另一种语法来指定它们的返回类型。
```c++
int f() {
  return 123;
}
// 对比
auto f() -> int {
  return 123;
}
```
```c++
auto g = []() -> int {
  return 123;
};
```
当某些返回类型无法解析时，此功能特别有用：
```c++
// 注意：这个无法编译！
template <typename T, typename U>
decltype(a + b) add(T a, U b) {
    return a + b;
}

// 尾随返回类型允许这样：
template <typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}
```
在 C++14 中，可以使用 [`decltype(auto) (C++14)`](README.md#decltypeauto) 代替。

### Noexcept 说明符
`noexcept` 说明符指定函数是否会抛出异常。它是 `throw()` 的改进版本。

```c++
void func1() noexcept;        // 不抛出
void func2() noexcept(true);  // 不抛出
void func3() throw();         // 不抛出

void func4() noexcept(false); // 可能抛出
```

不抛出异常的函数允许调用可能抛出异常的函数。每当抛出异常并且对处理程序的搜索遇到不抛出函数的最外层块时，将调用函数 std::terminate。

```c++
extern void f();  // 可能抛出
void g() noexcept {
    f();          // 有效，即使 f 抛出
    throw 42;     // 有效，实际上调用了 std::terminate
}
```

### char32_t 和 char16_t
提供用于表示 UTF-8 字符串的标准类型。
```c++
char32_t utf8_str[] = U"\u0123";
char16_t utf8_str[] = u"\u0123";
```

### 原始字符串字面量
C++11 引入了一种新的声明字符串字面量的方法，即"原始字符串字面量"。来自转义序列的字符（制表符、换行符、单个反斜杠等）可以原始输入，同时保留格式。这很有用，例如，用于编写可能包含大量引号或特殊格式的文本。这可以使您的字符串字面量更易于阅读和维护。

原始字符串字面量使用以下语法声明：
```
R"delimiter(raw_characters)delimiter"
```
其中：
* `delimiter` 是由任何源字符（除了括号、反斜杠和空格）组成的可选字符序列。
* `raw_characters` 是任何原始字符序列；不能包含结束序列 `")delimiter"`。

示例：
```cpp
// msg1 和 msg2 是等价的。
const char* msg1 = "\nHello,\n\tworld!\n";
const char* msg2 = R"(
Hello,
	world!
)";
```

## C++11 库特性

### std::move
`std::move` 指示传递给它的对象可能已经转移了其资源。使用已被移动的对象应小心，因为它们可能处于未指定状态（参见：[我能对已移动的对象做什么？](http://stackoverflow.com/questions/7027523/what-can-i-do-with-a-moved-from-object)）。

`std::move` 的定义（执行移动只不过是强制转换为右值引用）：
```c++
template <typename T>
typename remove_reference<T>::type&& move(T&& arg) {
  return static_cast<typename remove_reference<T>::type&&>(arg);
}
```

转移 `std::unique_ptr`：
```c++
std::unique_ptr<int> p1 {new int{0}};  // 实践中，使用 std::make_unique
std::unique_ptr<int> p2 = p1; // 错误 -- 不能复制 unique pointers
std::unique_ptr<int> p3 = std::move(p1); // 将 `p1` 移动到 `p3`
                                         // 现在解引用由 `p1` 持有的对象是不安全的
```

### std::forward
返回传递给它的参数，同时保持其值类别和 cv 限定符。对于泛型代码和工厂非常有用。与[`转发引用`](#转发引用)结合使用。

`std::forward` 的定义：
```c++
template <typename T>
T&& forward(typename remove_reference<T>::type& arg) {
  return static_cast<T&&>(arg);
}
```

一个函数 `wrapper` 的示例，它只是将其他 `A` 对象转发到新 `A` 对象的拷贝或移动构造函数：
```c++
struct A {
  A() = default;
  A(const A& o) { std::cout << "copied" << std::endl; }
  A(A&& o) { std::cout << "moved" << std::endl; }
};

template <typename T>
A wrapper(T&& arg) {
  return A{std::forward<T>(arg)};
}

wrapper(A{}); // moved
A a;
wrapper(a); // copied
wrapper(std::move(a)); // moved
```

另请参阅：[`转发引用`](#转发引用), [`右值引用`](#右值引用)。

### std::thread
`std::thread` 库提供了一种标准的方式来控制线程，例如生成和终止它们。在下面的示例中，生成多个线程来执行不同的计算，然后程序等待所有线程完成。

```c++
void foo(bool clause) { /* 做一些事情... */ }

std::vector<std::thread> threadsVector;
threadsVector.emplace_back([]() {
  // 将被调用的 Lambda 函数
});
threadsVector.emplace_back(foo, true);  // 线程将运行 foo(true)
for (auto& thread : threadsVector) {
  thread.join(); // 等待线程完成
}
```

### std::to_string
将数字参数转换为 `std::string`。
```c++
std::to_string(1.2); // == "1.2"
std::to_string(123); // == "123"
```

### 类型特征
类型特征定义了一个基于模板的编译时接口，用于查询或修改类型的属性。
```c++
static_assert(std::is_integral<int>::value);
static_assert(std::is_same<int, int>::value);
static_assert(std::is_same<std::conditional<true, int, double>::type, int>::value);
```

### 智能指针
C++11 引入了新的智能指针：`std::unique_ptr`、`std::shared_ptr`、`std::weak_ptr`。`std::auto_ptr` 现在被弃用，并最终在 C++17 中被移除。

`std::unique_ptr` 是一个不可复制、可移动的指针，管理其自己堆分配的内存。**注意：优先使用 `std::make_X` 辅助函数，而不是使用构造函数。请参阅 [std::make_unique](https://github.com/AnthonyCalandra/modern-cpp-features/blob/master/CPP14.md#stdmake_unique) 和 [std::make_shared](#stdmake_shared) 部分。**
```c++
std::unique_ptr<Foo> p1 { new Foo{} };  // `p1` 拥有 `Foo`
if (p1) {
  p1->bar();
}

{
  std::unique_ptr<Foo> p2 {std::move(p1)};  // 现在 `p2` 拥有 `Foo`
  f(*p2);

  p1 = std::move(p2);  // 所有权返回给 `p1` -- `p2` 被销毁
}

if (p1) {
  p1->bar();
}
// 当 `p1` 离开作用域时，`Foo` 实例被销毁
```

`std::shared_ptr` 是一个智能指针，管理在多个所有者之间共享的资源。共享指针持有一个*控制块*，该控制块包含几个组件，例如托管对象和引用计数器。所有控制块访问都是线程安全的，但是，操作托管对象本身是*非*线程安全的。
```c++
void foo(std::shared_ptr<T> t) {
  // 用 `t` 做点事...
}

void bar(std::shared_ptr<T> t) {
  // 用 `t` 做点事...
}

void baz(std::shared_ptr<T> t) {
  // 用 `t` 做点事...
}

std::shared_ptr<T> p1 {new T{}};
// 也许这些发生在其他线程中？
foo(p1);
bar(p1);
baz(p1);
```

### std::chrono
chrono 库包含一组处理*持续时间*、*时钟*和*时间点*的实用函数和类型。该库的一个用例是对代码进行基准测试：
```c++
std::chrono::time_point<std::chrono::steady_clock> start, end;
start = std::chrono::steady_clock::now();
// 一些计算...
end = std::chrono::steady_clock::now();

std::chrono::duration<double> elapsed_seconds = end - start;
double t = elapsed_seconds.count(); // t 秒数，表示为 `double`
```

### 元组
元组是异构值的固定大小集合。通过使用 [`std::tie`](#stdtie) 解包或使用 `std::get` 来访问 `std::tuple` 的元素。
```c++
// `playerProfile` 的类型是 `std::tuple<int, const char*, const char*>`。
auto playerProfile = std::make_tuple(51, "Frans Nielsen", "NYI");
std::get<0>(playerProfile); // 51
std::get<1>(playerProfile); // "Frans Nielsen"
std::get<2>(playerProfile); // "NYI"
```

### std::tie
创建左值引用的元组。对于解包 `std::pair` 和 `std::tuple` 对象非常有用。使用 `std::ignore` 作为被忽略值的占位符。在 C++17 中，应改用结构化绑定。
```c++
// With tuples...
std::string playerName;
std::tie(std::ignore, playerName, std::ignore) = std::make_tuple(91, "John Tavares", "NYI");

// With pairs...
std::string yes, no;
std::tie(yes, no) = std::make_pair("yes", "no");
```

### std::array
`std::array` 是一个封装了 C 风格数组的容器，支持常见的容器操作（例如排序）。
```cpp
std::array<int, 3> a = {2, 1, 3};
std::sort(a.begin(), a.end()); // a == { 1, 2, 3 }
for (int& x : a) x *= 2; // a == { 2, 4, 6 }
```

### 无序关联容器
这些容器通过哈希将元素映射到桶中，以牺牲元素顺序为代价，为查找、插入和删除操作提供了平均常数时间复杂度。主要包括四种类型：
* `unordered_set`
* `unordered_multiset`
* `unordered_map`
* `unordered_multimap`

### std::make_shared
`std::make_shared` 是创建 `std::shared_ptr` 的推荐方式，原因如下：
* **避免使用 `new` 运算符**：简化代码编写。
* **防止重复类型声明**：无需在智能指针构造时重复指定所持有对象的类型。
* **提供异常安全**：例如，在函数调用中若参数表达式求值顺序导致内存分配后发生异常，使用 `new` 可能引发内存泄漏，而 `std::make_shared` 能避免此问题。
* **提升性能**：通常只需一次内存分配（同时为对象和控制块分配内存），而直接使用 `std::shared_ptr(new T)` 需要两次分配。

```cpp
// 可能存在内存泄漏的写法
foo(std::shared_ptr<T>{new T{}}, function_that_throws(), std::shared_ptr<T>{new T{}});

// 异常安全的写法
foo(std::make_shared<T>(), function_that_throws(), std::make_shared<T>());
```
（更多关于 `std::unique_ptr` 和 `std::shared_ptr` 的信息，请参阅智能指针章节。）

### std::ref 与 std::cref
`std::ref(val)` 用于创建持有 `val` 引用的 `std::reference_wrapper` 对象。在常规引用传递 (`&`) 无法编译或因类型推导被丢弃时使用。`std::cref` 类似，但持有的是常量引用。
```cpp
int val = 99;
auto _ref = std::ref(val);
_ref++; // 修改 val
auto _cref = std::cref(val);
// _cref++; // 错误：不能修改常量引用

// std::vector<int&> vec; 错误：不能直接存储引用
std::vector<std::reference_wrapper<int>> vec; // 使用 reference_wrapper
vec.push_back(_ref);

std::cout << val << std::endl; // 输出 100
std::cout << vec[0] << std::endl; // 输出 100
std::cout << _cref << std::endl; // 输出 100
```

### std::begin 与 std::end
`std::begin` 和 `std::end` 是自由函数，用于泛型地获取容器的起始和结束迭代器。它们也适用于原生数组（原生数组没有 `begin` 和 `end` 成员函数）。
```cpp
template <typename T>
int CountTwos(const T& container) {
  return std::count_if(std::begin(container), std::end(container), [](int item) {
    return item == 2;
  });
}

std::vector<int> vec = {2, 2, 43, 435, 4543, 534};
int arr[8] = {2, 43, 45, 435, 32, 32, 32, 32};
auto a = CountTwos(vec); // 2
auto b = CountTwos(arr);  // 1
```

### 内存模型 (Memory Model)
C++11 引入了内存模型，为多线程编程和原子操作提供了库支持。包括（但不限于）原子加载/存储、比较并交换、原子标志、承诺 (promise)、未来值 (future)、锁 (lock) 和条件变量 (condition variable) 等操作。
（更多信息请参阅 `std::thread` 等章节。）

### std::async
`std::async` 异步或延迟运行给定的函数，并返回一个持有函数调用结果的 `std::future`。
第一个参数是启动策略：
1. `std::launch::async`：在新线程上执行可调用对象。
2. `std::launch::deferred`：在当前线程上延迟求值（惰性求值）。
3. `std::launch::async | std::launch::deferred`：由实现选择执行方式（默认）。

```cpp
int foo() {
  /* 执行一些操作，然后返回结果 */
  return 1000;
}

auto handle = std::async(std::launch::async, foo);  // 创建异步任务
auto result = handle.get();  // 等待并获取结果
```

---

### 致谢 (Acknowledgements)
* [cppreference](http://en.cppreference.com/w/cpp) - 查找新库特性的示例和文档非常有用。
* [C++ Rvalue References Explained](http://web.archive.org/web/20240324121501/http://thbecker.net/articles/rvalue_references/section_01.html) - 理解右值引用、完美转发和移动语义的优秀资料。
* [clang](http://clang.llvm.org/cxx_status.html) 和 [gcc](https://gcc.gnu.org/projects/cxx-status.html) 的标准支持页面及相关提案文档。
* [Compiler explorer](https://godbolt.org/)
* [Scott Meyers' Effective Modern C++](https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996) - 强烈推荐的书籍！
* [Jason Turner's C++ Weekly](https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw) - 优质的 C++ 相关视频集合。
* 以及众多 Stack Overflow 帖子和社区资源。