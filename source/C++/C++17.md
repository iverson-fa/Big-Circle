# C++17

## 概述

C++17 包含以下新语言特性：
- [类模板的参数推导](#类模板的参数推导)
- [使用auto声明非类型模板参数](#使用auto声明非类型模板参数)
- [折叠表达式](#折叠表达式)
- [从braced-init-list进行auto推导的新规则](#从braced-init-list进行auto推导的新规则)
- [constexpr lambda](#constexpr-lambda)
- [Lambda按值捕获this](#lambda按值捕获this)
- [内联变量](#内联变量)
- [嵌套命名空间](#嵌套命名空间)
- [结构化绑定](#结构化绑定)
- [带初始化器的选择语句](#带初始化器的选择语句)
- [constexpr if](#constexpr-if)
- [UTF-8字符字面量](#utf-8字符字面量)
- [枚举的直接列表初始化](#枚举的直接列表初始化)
- [\[\[fallthrough\]\], \[\[nodiscard\]\], \[\[maybe_unused\]\]属性](#fallthrough-nodiscard-maybe_unused属性)
- [\_\_has\_include](#__has_include)
- [类模板参数推导](#类模板参数推导)

C++17 包含以下新库特性：
- [std::variant](#stdvariant)
- [std::optional](#stdoptional)
- [std::any](#stdany)
- [std::string_view](#stdstring_view)
- [std::invoke](#stdinvoke)
- [std::apply](#stdapply)
- [std::filesystem](#stdfilesystem)
- [std::byte](#stdbyte)
- [map和set的接合操作](#map和set的接合操作)
- [并行算法](#并行算法)
- [std::sample](#stdsample)
- [std::clamp](#stdclamp)
- [std::reduce](#stdreduce)
- [前缀和算法](#前缀和算法)
- [gcd和lcm](#gcd和lcm)
- [std::not_fn](#stdnot_fn)
- [字符串与数字的转换](#字符串与数字的转换)
- [chrono时长和时间点的舍入函数](#chrono时长和时间点的舍入函数)

## C++17 语言特性

### 类模板的参数推导
自动模板参数推导，类似于函数的模板参数推导，但现在包括类的构造函数。
```cpp
template <typename T = float>
struct MyContainer {
  T val;
  MyContainer() : val{} {}
  MyContainer(T val) : val{val} {}
  // ...
};
MyContainer c1 {1}; // 正确：MyContainer<int>
MyContainer c2; // 正确：MyContainer<float>
```

### 使用auto声明非类型模板参数
遵循`auto`的推导规则，同时尊重非类型模板参数允许的类型列表[*]，模板参数可以从其参数的类型中推导：
```cpp
template <auto... seq>
struct my_integer_sequence {
  // 实现...
};

// 显式传递类型`int`作为模板参数。
auto seq = std::integer_sequence<int, 0, 1, 2>();
// 类型被推导为`int`。
auto seq2 = my_integer_sequence<0, 1, 2>();
```
* - 例如，不能使用`double`作为模板参数类型，这也使得使用`auto`进行此类推导无效。

### 折叠表达式
折叠表达式对模板参数包执行二元操作符的折叠。
* 形式为`(... op e)`或`(e op ...)`的表达式，其中`op`是折叠操作符，`e`是未展开的参数包，称为_一元折叠_。
* 形式为`(e1 op ... op e2)`的表达式，其中`op`是折叠操作符，称为_二元折叠_。`e1`或`e2`是未展开的参数包，但不能同时都是。
```cpp
template <typename... Args>
bool logicalAnd(Args... args) {
    // 二元折叠。
    return (true && ... && args);
}
bool b = true;
bool& b2 = b;
logicalAnd(b, b2, true); // == true
```
```cpp
template <typename... Args>
auto sum(Args... args) {
    // 一元折叠。
    return (... + args);
}
sum(1.0, 2.0f, 3); // == 6.0
```

### 从braced-init-list进行auto推导的新规则
改进了与统一初始化语法一起使用时的`auto`推导。之前，`auto x {3};`推导为`std::initializer_list<int>`，现在推导为`int`。
```cpp
auto x1 {1, 2, 3}; // 错误：不是单个元素
auto x2 = {1, 2, 3}; // x2是std::initializer_list<int>
auto x3 {3}; // x3是int
auto x4 {3.0}; // x4是double
```

### constexpr lambda
使用`constexpr`的编译时lambda。
```cpp
auto identity = [](int n) constexpr { return n; };
static_assert(identity(123) == 123);
```
```cpp
constexpr auto add = [](int x, int y) {
  auto L = [=] { return x; };
  auto R = [=] { return y; };
  return [=] { return L() + R(); };
};

static_assert(add(1, 2)() == 3);
```
```cpp
constexpr int addOne(int n) {
  return [n] { return n + 1; }();
}

static_assert(addOne(1) == 2);
```

### Lambda按值捕获this
在lambda环境中捕获`this`之前只能是引用。这在异步代码中使用回调时会出现问题，因为回调可能需要对象在超出其生命周期后仍然可用。`*this`（C++17）现在会创建当前对象的副本，而`this`（C++11）继续按引用捕获。
```cpp
struct MyObj {
  int value {123};
  auto getValueCopy() {
    return [*this] { return value; };
  }
  auto getValueRef() {
    return [this] { return value; };
  }
};
MyObj mo;
auto valueCopy = mo.getValueCopy();
auto valueRef = mo.getValueRef();
mo.value = 321;
valueCopy(); // 123
valueRef(); // 321
```

### 内联变量
`inline`说明符可以应用于变量以及函数。声明为内联的变量具有与声明为内联的函数相同的语义。
```cpp
// 使用编译器资源管理器的反汇编示例。
struct S { int x; };
inline S x1 = S{321}; // mov esi, dword ptr [x1]
                      // x1: .long 321

S x2 = S{123};        // mov eax, dword ptr [.L_ZZ4mainE2x2]
                      // mov dword ptr [rbp - 8], eax
                      // .L_ZZ4mainE2x2: .long 123
```

它也可以用于声明和定义静态成员变量，这样就不需要在源文件中初始化。
```cpp
struct S {
  S() : id{count++} {}
  ~S() { count--; }
  int id;
  static inline int count{0}; // 在类内声明并初始化count为0
};
```

### 嵌套命名空间
使用命名空间解析运算符创建嵌套命名空间定义。
```cpp
namespace A {
  namespace B {
    namespace C {
      int i;
    }
  }
}
```

上面的代码可以这样写：
```cpp
namespace A::B::C {
  int i;
}
```

### 结构化绑定
解构初始化的提案，允许编写`auto [ x, y, z ] = expr;`，其中`expr`的类型是类似元组的对象，其元素将绑定到变量`x`、`y`和`z`（此构造声明这些变量）。_类似元组的对象_包括[`std::tuple`](README.md#tuples)、`std::pair`、[`std::array`](README.md#stdarray)和聚合结构。
```cpp
using Coordinate = std::pair<int, int>;
Coordinate origin() {
  return Coordinate{0, 0};
}

const auto [ x, y ] = origin();
x; // == 0
y; // == 0
```
```cpp
std::unordered_map<std::string, int> mapping {
  {"a", 1},
  {"b", 2},
  {"c", 3}
};

// 通过引用解构。
for (const auto& [key, value] : mapping) {
  // 对key和value进行操作
}
```

### 带初始化器的选择语句
新版本的`if`和`switch`语句，简化了常见代码模式，帮助用户保持作用域紧凑。
```cpp
{
  std::lock_guard<std::mutex> lk(mx);
  if (v.empty()) v.push_back(val);
}
// 对比
if (std::lock_guard<std::mutex> lk(mx); v.empty()) {
  v.push_back(val);
}
```
```cpp
Foo gadget(args);
switch (auto s = gadget.status()) {
  case OK: gadget.zip(); break;
  case Bad: throw BadFoo(s.message());
}
// 对比
switch (Foo gadget(args); auto s = gadget.status()) {
  case OK: gadget.zip(); break;
  case Bad: throw BadFoo(s.message());
}
```

### constexpr if
编写根据编译时条件实例化的代码。
```cpp
template <typename T>
constexpr bool isIntegral() {
  if constexpr (std::is_integral<T>::value) {
    return true;
  } else {
    return false;
  }
}
static_assert(isIntegral<int>() == true);
static_assert(isIntegral<char>() == true);
static_assert(isIntegral<double>() == false);
struct S {};
static_assert(isIntegral<S>() == false);
```

### UTF-8字符字面量
以`u8`开头的字符字面量是`char`类型的字符字面量。UTF-8字符字面量的值等于其ISO 10646码点值。
```cpp
char x = u8'x';
```

### 枚举的直接列表初始化
枚举现在可以使用大括号语法初始化。
```cpp
enum byte : unsigned char {};
byte b {0}; // 正确
byte c {-1}; // 错误
byte d = byte{1}; // 正确
byte e = byte{256}; // 错误
```

### [[fallthrough]], [[nodiscard]], [[maybe_unused]]属性
C++17引入了三个新属性：`[[fallthrough]]`、`[[nodiscard]]`和`[[maybe_unused]]`。
* `[[fallthrough]]`向编译器指示在switch语句中贯穿是预期行为。此属性只能在switch语句中使用，并且必须放在下一个case/default标签之前。
```cpp
switch (n) {
  case 1:
    // ...
    [[fallthrough]];
  case 2:
    // ...
    break;
  case 3:
    // ...
    [[fallthrough]];
  default:
    // ...
}
```

* `[[nodiscard]]`当函数或类具有此属性且其返回值被丢弃时发出警告。
```cpp
[[nodiscard]] bool do_something() {
  return is_success; // 成功为true，失败为false
}

do_something(); // 警告：忽略声明为'nodiscard'属性的'bool do_something()'的返回值
```
```cpp
// 仅当`error_info`按值返回时发出警告。
struct [[nodiscard]] error_info {
  // ...
};

error_info do_something() {
  error_info ei;
  // ...
  return ei;
}

do_something(); // 警告：忽略声明为'nodiscard'属性的类型'error_info'的返回值
```

* `[[maybe_unused]]`向编译器指示变量或参数可能未被使用是预期的。
```cpp
void my_callback(std::string msg, [[maybe_unused]] bool error) {
  // 不关心`msg`是否是错误消息，只是记录它。
  log(msg);
}
```

### __has_include

`__has_include (operand)`运算符可用于`#if`和`#elif`表达式中，以检查头文件或源文件（`operand`）是否可用于包含。

此功能的一个用例是使用两个功能相同的库，如果系统上找不到首选的库，则使用备用/实验性库。

```cpp
#ifdef __has_include
#  if __has_include(<optional>)
#    include <optional>
#    define have_optional 1
#  elif __has_include(<experimental/optional>)
#    include <experimental/optional>
#    define have_optional 1
#    define experimental_optional
#  else
#    define have_optional 0
#  endif
#endif
```

它还可以用于包含在不同平台上位于不同名称或位置的头文件，而无需知道程序运行在哪个平台上，OpenGL头文件就是一个很好的例子，它们在macOS上位于`OpenGL\`目录，在其他平台上位于`GL\`目录。

```cpp
#ifdef __has_include
#  if __has_include(<OpenGL/gl.h>)
#    include <OpenGL/gl.h>
#    include <OpenGL/glu.h>
#  elif __has_include(<GL/gl.h>)
#    include <GL/gl.h>
#    include <GL/glu.h>
#  else
#    error 未找到合适的OpenGL头文件。
# endif
#endif
```

### 类模板参数推导
*类模板参数推导*（CTAD）允许编译器从构造函数参数推导模板参数。
```cpp
std::vector v{ 1, 2, 3 }; // 推导为std::vector<int>

std::mutex mtx;
auto lck = std::lock_guard{ mtx }; // 推导为std::lock_guard<std::mutex>

auto p = new std::pair{ 1.0, 2.0 }; // 推导为std::pair<double, double>*
```

对于用户定义的类型，可以使用*推导指南*来指导编译器如何推导模板参数（如果适用）：
```cpp
template <typename T>
struct container {
  container(T t) {}

  template <typename Iter>
  container(Iter beg, Iter end);
};

// 推导指南
template <typename Iter>
container(Iter b, Iter e) -> container<typename std::iterator_traits<Iter>::value_type>;

container a{ 7 }; // 正确：推导为container<int>

std::vector<double> v{ 1.0, 2.0, 3.0 };
auto b = container{ v.begin(), v.end() }; // 正确：推导为container<double>

container c{ 5, 6 }; // 错误：std::iterator_traits<int>::value_type不是类型
```

## C++17 库特性

### std::variant
类模板`std::variant`表示一个类型安全的`union`。`std::variant`的实例在任何给定时间持有其替代类型之一的值（也可能无值）。
```cpp
std::variant<int, double> v{ 12 };
std::get<int>(v); // == 12
std::get<0>(v); // == 12
v = 12.0;
std::get<double>(v); // == 12.0
std::get<1>(v); // == 12.0
```

### std::optional
类模板`std::optional`管理一个可选的包含值，即可能存在也可能不存在的值。optional的一个常见用例是可能失败的函数的返回值。
```cpp
std::optional<std::string> create(bool b) {
  if (b) {
    return "Godzilla";
  } else {
    return {};
  }
}

create(false).value_or("empty"); // == "empty"
create(true).value(); // == "Godzilla"
// 返回optional的工厂函数可用作while和if的条件
if (auto str = create(true)) {
  // ...
}
```

### std::any
用于任何类型的单个值的类型安全容器。
```cpp
std::any x {5};
x.has_value() // == true
std::any_cast<int>(x) // == 5
std::any_cast<int&>(x) = 10;
std::any_cast<int>(x) // == 10
```

### std::string_view
字符串的非拥有引用。用于在字符串之上提供抽象（例如用于解析）。
```cpp
// 常规字符串。
std::string_view cppstr {"foo"};
// 宽字符串。
std::wstring_view wcstr_v {L"baz"};
// 字符数组。
char array[3] = {'b', 'a', 'r'};
std::string_view array_v(array, std::size(array));
```
```cpp
std::string str {"   trim me"};
std::string_view v {str};
v.remove_prefix(std::min(v.find_first_not_of(" "), v.size()));
str; //  == "   trim me"
v; // == "trim me"
```

### std::invoke
使用参数调用`Callable`对象。*可调用*对象的例子包括`std::function`或lambda；可以像常规函数一样调用的对象。
```cpp
template <typename Callable>
class Proxy {
  Callable c_;

public:
  Proxy(Callable c) : c_{ std::move(c) } {}

  template <typename... Args>
  decltype(auto) operator()(Args&&... args) {
    // ...
    return std::invoke(c_, std::forward<Args>(args)...);
  }
};

const auto add = [](int x, int y) { return x + y; };
Proxy p{ add };
p(1, 2); // == 3
```

### std::apply
使用元组参数调用`Callable`对象。
```cpp
auto add = [](int x, int y) {
  return x + y;
};
std::apply(add, std::make_tuple(1, 2)); // == 3
```

### std::filesystem
新的`std::filesystem`库提供了操作文件系统中文件、目录和路径的标准方法。

以下示例中，如果有可用空间，则将大文件复制到临时路径：
```cpp
const auto bigFilePath {"bigFileToCopy"};
if (std::filesystem::exists(bigFilePath)) {
  const auto bigFileSize {std::filesystem::file_size(bigFilePath)};
  std::filesystem::path tmpPath {"/tmp"};
  if (std::filesystem::space(tmpPath).available > bigFileSize) {
    std::filesystem::create_directory(tmpPath.append("example"));
    std::filesystem::copy_file(bigFilePath, tmpPath.append("newFile"));
  }
}
```

### std::byte
新的`std::byte`类型提供了将数据表示为字节的标准方法。使用`std::byte`相对于`char`或`unsigned char`的好处是它不是字符类型，也不是算术类型；唯一可用的运算符重载是按位操作。
```cpp
std::byte a {0};
std::byte b {0xFF};
int i = std::to_integer<int>(b); // 0xFF
std::byte c = a & b;
int j = std::to_integer<int>(c); // 0
```
注意`std::byte`只是一个枚举，由于[枚举的直接列表初始化](#枚举的直接列表初始化)，枚举的大括号初始化成为可能。

### map和set的接合操作
移动节点和合并容器，而没有昂贵拷贝、移动或堆分配/释放的开销。

将元素从一个map移动到另一个：
```cpp
std::map<int, string> src {{1, "one"}, {2, "two"}, {3, "buckle my shoe"}};
std::map<int, string> dst {{3, "three"}};
dst.insert(src.extract(src.find(1))); // 廉价地从`src`移除并插入{ 1, "one" }到`dst`。
dst.insert(src.extract(2)); // 廉价地从`src`移除并插入{ 2, "two" }到`dst`。
// dst == { { 1, "one" }, { 2, "two" }, { 3, "three" } };
```

插入整个set：
```cpp
std::set<int> src {1, 3, 5};
std::set<int> dst {2, 4, 5};
dst.merge(src);
// src == { 5 }
// dst == { 1, 2, 3, 4, 5 }
```

插入比容器寿命更长的元素：
```cpp
auto elementFactory() {
  std::set<...> s;
  s.emplace(...);
  return s.extract(s.begin());
}
s2.insert(elementFactory());
```

更改map元素的键：
```cpp
std::map<int, string> m {{1, "one"}, {2, "two"}, {3, "three"}};
auto e = m.extract(2);
e.key() = 4;
m.insert(std::move(e));
// m == { { 1, "one" }, { 3, "three" }, { 4, "two" } }
```

### 并行算法
许多STL算法，如`copy`、`find`和`sort`方法，开始支持*并行执行策略*：`seq`、`par`和`par_unseq`，分别表示"顺序"、"并行"和"并行无序"。

```cpp
std::vector<int> longVector;
// 使用并行执行策略查找元素
auto result1 = std::find(std::execution::par, std::begin(longVector), std::end(longVector), 2);
// 使用顺序执行策略排序元素
auto result2 = std::sort(std::execution::seq, std::begin(longVector), std::end(longVector));
```

### std::sample
从给定序列中采样n个元素（无放回），其中每个元素被选中的机会相等。
```cpp
const std::string ALLOWED_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
std::string guid;
// 从ALLOWED_CHARS中采样5个字符。
std::sample(ALLOWED_CHARS.begin(), ALLOWED_CHARS.end(), std::back_inserter(guid),
  5, std::mt19937{ std::random_device{}() });

std::cout << guid; // 例如 G1fW2
```

### std::clamp
将给定值限制在下界和上界之间。
```cpp
std::clamp(42, -1, 1); // == 1
std::clamp(-42, -1, 1); // == -1
std::clamp(0, -1, 1); // == 0

// `std::clamp`也接受自定义比较器：
std::clamp(0, -1, 1, std::less<>{}); // == 0
```

### std::reduce
对给定范围的元素进行折叠。概念上类似于`std::accumulate`，但`std::reduce`将并行执行折叠。由于折叠是并行完成的，如果指定二元操作，它必须是结合律和交换律的。给定的二元操作也不应更改任何元素或使给定范围内的任何迭代器失效。

默认的二元操作是std::plus，初始值为0。
```cpp
const std::array<int, 3> a{ 1, 2, 3 };
std::reduce(std::cbegin(a), std::cend(a)); // == 6
// 使用自定义二元操作：
std::reduce(std::cbegin(a), std::cend(a), 1, std::multiplies<>{}); // == 6
```
此外，可以为归约器指定变换：
```cpp
std::transform_reduce(std::cbegin(a), std::cend(a), 0, std::plus<>{}, times_ten); // == 60

const std::array<int, 3> b{ 1, 2, 3 };
const auto product_times_ten = [](const auto a, const auto b) { return a * b * 10; };

std::transform_reduce(std::cbegin(a), std::cend(a), std::cbegin(b), 0, std::plus<>{}, product_times_ten); // == 140
```

### 前缀和算法
支持前缀和（包括包含性和排他性扫描）以及变换。
```cpp
const std::array<int, 3> a{ 1, 2, 3 };

std::inclusive_scan(std::cbegin(a), std::cend(a),
    std::ostream_iterator<int>{ std::cout, " " }, std::plus<>{}); // 1 3 6

std::exclusive_scan(std::cbegin(a), std::cend(a),
    std::ostream_iterator<int>{ std::cout, " " }, 0, std::plus<>{}); // 0 1 3

const auto times_ten = [](const auto n) { return n * 10; };

std::transform_inclusive_scan(std::cbegin(a), std::cend(a),
    std::ostream_iterator<int>{ std::cout, " " }, std::plus<>{}, times_ten); // 10 30 60

std::transform_exclusive_scan(std::cbegin(a), std::cend(a),
    std::ostream_iterator<int>{ std::cout, " " }, 0, std::plus<>{}, times_ten); // 0 10 30
```

### gcd和lcm
最大公约数（GCD）和最小公倍数（LCM）。
```cpp
const int p = 9;
const int q = 3;
std::gcd(p, q); // == 3
std::lcm(p, q); // == 9
```

### std::not_fn
返回给定函数结果否定的实用函数。
```cpp
const std::ostream_iterator<int> ostream_it{ std::cout, " " };
const auto is_even = [](const auto n) { return n % 2 == 0; };
std::vector<int> v{ 0, 1, 2, 3, 4 };

// 打印所有偶数。
std::copy_if(std::cbegin(v), std::cend(v), ostream_it, is_even); // 0 2 4
// 打印所有奇数（非偶数）。
std::copy_if(std::cbegin(v), std::cend(v), ostream_it, std::not_fn(is_even)); // 1 3
```

### 字符串与数字的转换
将整数和浮点数转换为字符串或反之。转换是非抛出的，不分配内存，并且比C标准库中的等效函数更安全。

用户负责为`std::to_chars`分配足够的存储空间，否则函数将通过在其返回值中设置错误代码对象而失败。

这些函数允许您可选地传递基数（默认为10进制）或浮点类型输入的格式说明符。

* `std::to_chars`返回一个（非const）char指针，指向函数在给定缓冲区中写入的字符串的结尾之后的位置，以及一个错误代码对象。
* `std::from_chars`返回一个const char指针，成功时等于传递给函数的结束指针，以及一个错误代码对象。

这些函数返回的错误代码对象在成功时等于默认初始化的错误代码对象。

将数字`123`转换为`std::string`：
```cpp
const int n = 123;

// 可以使用任何容器、字符串、数组等。
std::string str;
str.resize(3); // 为`n`的每个数字保留足够的存储空间

const auto [ ptr, ec ] = std::to_chars(str.data(), str.data() + str.size(), n);

if (ec == std::errc{}) { std::cout << str << std::endl; } // 123
else { /* 处理失败 */ }
```

从值为`"123"`的`std::string`转换为整数：
```cpp
const std::string str{ "123" };
int n;

const auto [ ptr, ec ] = std::from_chars(str.data(), str.data() + str.size(), n);

if (ec == std::errc{}) { std::cout << n << std::endl; } // 123
else { /* 处理失败 */ }
```

### chrono时长和时间点的舍入函数
为`std::chrono::duration`和`std::chrono::time_point`提供abs、round、ceil和floor辅助函数。
```cpp
using seconds = std::chrono::seconds;
std::chrono::milliseconds d{ 5500 };
std::chrono::abs(d); // == 5s
std::chrono::round<seconds>(d); // == 6s
std::chrono::ceil<seconds>(d); // == 6s
std::chrono::floor<seconds>(d); // == 5s
```

## 致谢
* [cppreference](http://en.cppreference.com/w/cpp) - 对于查找新库特性的示例和文档特别有用。
* [C++右值引用详解](http://web.archive.org/web/20240324121501/http://thbecker.net/articles/rvalue_references/section_01.html) - 我用来理解右值引用、完美转发和移动语义的优秀介绍。
* [clang](http://clang.llvm.org/cxx_status.html) 和 [gcc](https://gcc.gnu.org/projects/cxx-status.html) 的标准支持页面。这里还包括我用来帮助查找描述、它旨在修复的问题以及一些示例的语言/库特性提案。
* [Compiler explorer](https://godbolt.org/)
* [Scott Meyers的《Effective Modern C++》](https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996) - 强烈推荐的书籍！
* [Jason Turner的C++ Weekly](https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw) - 不错的C++相关视频集合。
* [我能对移动后的对象做什么？](http://stackoverflow.com/questions/7027523/what-can-i-do-with-a-moved-from-object)
* [decltype(auto)的一些用途？](http://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto)